# IDR-002: CEF Framework Core Implementation Plan

**Status:** In Progress  
**Date:** 2024-11-24  
**Authors:** CEF Implementation Team  
**Based On:** ADR-002 (Framework Architecture Design)  
**Target:** cef-framework module implementation with 60% test coverage

---

## Executive Summary

This Implementation Decision Record (IDR) provides a **concrete, step-by-step implementation plan** for the `cef-framework` module based on ADR-002's design. The plan is organized into **15 implementation phases** with specific deliverables, test requirements, and success criteria. ALL features from requirements.md and ADR-002.md are included - NO deferrals.

**Target Metrics:**
- **Test Coverage:** 60% minimum (line coverage)
- **Implementation Time:** 12-15 weeks (single developer)
- **Code Quality:** SonarQube quality gate pass
- **Documentation:** JavaDoc for all public APIs

---

## Current State Assessment

### ✅ **Completed (5% of Framework)**
- Domain entities: `Node`, `Edge`, `Chunk`, `RelationType`, `RelationSemantics`
- Maven project structure
- Dependency management (Spring Boot, Spring AI, JGraphT, ANTLR)
- Database schemas (DuckDB, PostgreSQL)

### ❌ **Not Implemented (95% of Framework)**
- All interfaces (`KnowledgeIndexer`, `KnowledgeRetriever`)
- All repositories (R2DBC)
- All services (indexing, retrieval, graph management)
- Parser system (ANTLR-based)
- DataSource adapters (FileSystem, S3/MinIO)
- LLM client factory
- Context provider tool
- Configuration binding
- Auto-configuration

---

## Implementation Phases

**Total: 15 Phases over 12-15 weeks**

### **Phase 1: Repository Layer & Database Integration** (Week 1)

#### **Objective**
Implement Spring Data R2DBC repositories for reactive database access with proper schema initialization.

#### **Deliverables**

##### 1.1 Node Repository
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/repository/NodeRepository.java`

```java
@Repository
public interface NodeRepository extends R2dbcRepository<Node, UUID> {
    
    Flux<Node> findByLabel(String label);
    
    @Query("SELECT * FROM nodes WHERE properties @> :propertyJson")
    Flux<Node> findByProperty(String propertyJson);
    
    @Query("SELECT * FROM nodes WHERE vectorizable_content IS NOT NULL")
    Flux<Node> findAllWithVectorizableContent();
    
    Mono<Long> countByLabel(String label);
}
```

**Tests:** `NodeRepositoryTest.java`
- Test CRUD operations (create, read, update, delete)
- Test `findByLabel()` with multiple results
- Test `findByProperty()` with JSONB queries
- Test pagination and sorting
- **Coverage Target:** 80% (critical data layer)

##### 1.2 Edge Repository
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/repository/EdgeRepository.java`

```java
@Repository
public interface EdgeRepository extends R2dbcRepository<Edge, UUID> {
    
    Flux<Edge> findBySourceNodeId(UUID sourceNodeId);
    
    Flux<Edge> findByTargetNodeId(UUID targetNodeId);
    
    Flux<Edge> findByRelationType(String relationType);
    
    @Query("SELECT * FROM edges WHERE source_node_id = :nodeId OR target_node_id = :nodeId")
    Flux<Edge> findByNodeId(UUID nodeId);
    
    @Query("DELETE FROM edges WHERE source_node_id = :nodeId OR target_node_id = :nodeId")
    Mono<Void> deleteByNodeId(UUID nodeId);
}
```

**Tests:** `EdgeRepositoryTest.java`
- Test bidirectional edge creation
- Test cascade delete behavior
- Test finding edges by source/target
- **Coverage Target:** 80%

##### 1.3 Chunk Repository
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/repository/ChunkRepository.java`

```java
@Repository
public interface ChunkRepository extends R2dbcRepository<Chunk, UUID> {
    
    Flux<Chunk> findByLinkedNodeId(UUID linkedNodeId);
    
    @Query("SELECT *, (embedding <-> :queryEmbedding::vector) as distance " +
           "FROM chunks ORDER BY distance LIMIT :limit")
    Flux<Chunk> vectorSearch(float[] queryEmbedding, int limit);
    
    @Query("SELECT * FROM chunks WHERE to_tsvector('english', content) @@ plainto_tsquery(:query) " +
           "ORDER BY ts_rank(to_tsvector('english', content), plainto_tsquery(:query)) DESC " +
           "LIMIT :limit")
    Flux<Chunk> fullTextSearch(String query, int limit);
}
```

**Tests:** `ChunkRepositoryTest.java`
- Test vector search (mock embeddings)
- Test full-text search
- Test linked node queries
- **Coverage Target:** 75%

##### 1.4 RelationType Repository
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/repository/RelationTypeRepository.java`

```java
@Repository
public interface RelationTypeRepository extends R2dbcRepository<RelationType, String> {
    
    Flux<RelationType> findBySemantics(RelationSemantics semantics);
    
    Mono<Boolean> existsByName(String name);
}
```

**Tests:** `RelationTypeRepositoryTest.java`
- Test relation type registration
- Test semantic filtering
- **Coverage Target:** 70%

##### 1.5 Schema Initialization
**File:** `cef-framework/src/main/resources/schema-postgresql.sql`

Update with proper indexes:
```sql
-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_nodes_label ON nodes(label);
CREATE INDEX IF NOT EXISTS idx_edges_source ON edges(source_node_id);
CREATE INDEX IF NOT EXISTS idx_edges_target ON edges(target_node_id);
CREATE INDEX IF NOT EXISTS idx_edges_relation_type ON edges(relation_type);
CREATE INDEX IF NOT EXISTS idx_chunks_linked_node ON chunks(linked_node_id);

-- Add GIN index for JSONB properties
CREATE INDEX IF NOT EXISTS idx_nodes_properties ON nodes USING GIN(properties);

-- Add vector index (if pgvector available)
CREATE INDEX IF NOT EXISTS idx_chunks_embedding ON chunks USING ivfflat(embedding vector_cosine_ops);

-- Add full-text search index
CREATE INDEX IF NOT EXISTS idx_chunks_content_fts ON chunks USING GIN(to_tsvector('english', content));
```

**File:** `cef-framework/src/main/resources/schema-duckdb.sql`

Update with DuckDB-specific syntax (no pgvector, no GIN indexes).

#### **Phase 1 Success Criteria**
- ✅ All 4 repositories implemented with reactive operations
- ✅ Schemas initialized on startup
- ✅ All repository tests passing
- ✅ Test coverage: 75%+ for repository layer
- ✅ Integration tests with Testcontainers (PostgreSQL)

---

### **Phase 2: In-Memory Graph with JGraphT** (Week 2)

#### **Objective**
Implement the in-memory graph using JGraphT for fast traversal operations with dual persistence.

#### **Deliverables**

##### 2.1 Graph Manager
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/graph/InMemoryKnowledgeGraph.java`

```java
@Component
public class InMemoryKnowledgeGraph {
    
    private final Graph<UUID, EdgeWrapper> graph;
    private final Map<UUID, Node> nodeIndex;
    private final Map<String, Set<UUID>> labelIndex;
    private final Map<String, RelationType> relationTypes;
    
    public InMemoryKnowledgeGraph() {
        this.graph = new DirectedWeightedPseudograph<>(EdgeWrapper.class);
        this.nodeIndex = new ConcurrentHashMap<>();
        this.labelIndex = new ConcurrentHashMap<>();
        this.relationTypes = new ConcurrentHashMap<>();
    }
    
    // Node operations
    public void addNode(Node node);
    public void removeNode(UUID nodeId);
    public Optional<Node> findNode(UUID nodeId);
    public List<Node> findNodesByLabel(String label);
    
    // Edge operations
    public void addEdge(Edge edge);
    public void removeEdge(UUID edgeId);
    public Set<Edge> getEdges(UUID nodeId);
    
    // Graph traversal
    public List<Node> getParents(UUID nodeId);
    public List<Node> getChildren(UUID nodeId);
    public List<Node> getSiblings(UUID nodeId);
    public List<Node> getNeighbors(UUID nodeId, int depth);
    
    // Path finding
    public Optional<GraphPathResult> findShortestPath(UUID from, UUID to);
    public List<GraphPathResult> findAllPaths(UUID from, UUID to, int maxDepth);
    
    // BFS traversal for reasoning context
    public Set<Node> traverse(UUID startId, int depth, Set<RelationSemantics> semantics);
    
    // Statistics
    public long getNodeCount();
    public long getEdgeCount();
    public Map<String, Long> getLabelCounts();
    
    // Sync operations
    public void clear();
    public void loadFromDatabase(Flux<Node> nodes, Flux<Edge> edges);
}
```

**Internal Class:**
```java
// Wrapper to allow multiple edges between same nodes
private static class EdgeWrapper {
    private final Edge edge;
    // ... implementation
}
```

**Tests:** `InMemoryKnowledgeGraphTest.java`
- Test node add/remove/find
- Test edge add/remove
- Test parent/child/sibling queries
- Test BFS traversal with depth limit
- Test shortest path (Dijkstra)
- Test graph statistics
- Test concurrent access
- **Coverage Target:** 65%

##### 2.2 Graph Path Result DTO
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/graph/GraphPathResult.java`

```java
public record GraphPathResult(
    List<UUID> nodeIds,
    List<String> relationTypes,
    double totalWeight,
    int length
) {
    public static GraphPathResult fromJGraphTPath(
        org.jgrapht.GraphPath<UUID, EdgeWrapper> path
    ) {
        // ... conversion logic
    }
}
```

##### 2.3 GraphStore Interface (Abstraction)
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/store/GraphStore.java`

```java
public interface GraphStore {
    void addNode(Node node);
    void addEdge(Edge edge);
    void removeNode(UUID nodeId);
    Optional<Node> findNode(UUID id);
    List<Node> findNodesByLabel(String label);
    List<Node> getParents(UUID nodeId);
    List<Node> getChildren(UUID nodeId);
    ReasoningContext traverse(UUID startId, int depth, Set<RelationSemantics> semantics);
    Optional<GraphPath> findPath(UUID from, UUID to);
    String getImplementation();
}
```

##### 2.4 JGraphT Implementation (Default)
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/store/JGraphTGraphStore.java`

```java
@Component
@ConditionalOnProperty(name = "cef.graph.store", havingValue = "jgrapht", matchIfMissing = true)
public class JGraphTGraphStore implements GraphStore {
    // Use existing InMemoryKnowledgeGraph implementation
}
```

##### 2.5 Graph Configuration
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/config/GraphConfiguration.java`

```java
@Configuration
@ConfigurationProperties(prefix = "cef.graph")
public class GraphConfiguration {
    
    private String store = "jgrapht";  // jgrapht | neo4j | tinkerpop
    private boolean preloadOnStartup = true;
    private int maxNodes = 100000;
    private int maxEdges = 500000;
    private int defaultTraversalDepth = 2;
    
    // Neo4j config
    public static class Neo4j {
        private String uri = "bolt://localhost:7687";
        private String username = "neo4j";
        private String password = "password";
    }
    
    // getters/setters
}
```

#### **Phase 2 Success Criteria**
- ✅ JGraphT graph initialized with proper indexes
- ✅ O(1) node lookup by ID and label
- ✅ BFS/DFS traversal working
- ✅ Shortest path algorithm working
- ✅ Test coverage: 65%+ for graph layer
- ✅ Performance: <10ms for depth-3 traversal on 10K nodes

---

### **Phase 3: Knowledge Indexer Service** (Week 3)

#### **Objective**
Implement the `KnowledgeIndexer` interface for adding/updating knowledge graph with dual persistence.

#### **Deliverables**

##### 3.1 DTOs for Input
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/NodeInput.java`

```java
public record NodeInput(
    UUID id,                              // Optional
    String label,
    Map<String, Object> properties,
    String vectorizableContent            // Optional
) {
    public Node toEntity() {
        return new Node(
            id != null ? id : UUID.randomUUID(),
            label,
            properties,
            vectorizableContent
        );
    }
}
```

**Similar files:** `EdgeInput.java`, `ChunkInput.java`, `BatchInput.java`

##### 3.2 Indexer Interface
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/service/KnowledgeIndexer.java`

```java
public interface KnowledgeIndexer {
    
    // Initialization
    Mono<Void> initialize(List<NodeInput> rootNodes, List<RelationType> relationTypes);
    
    // Full indexing
    Mono<IndexResult> fullIndex();
    Mono<IndexResult> fullIndex(DataSource dataSource);
    
    // Incremental indexing
    Mono<Node> indexNode(NodeInput input);
    Mono<Edge> indexEdge(EdgeInput input);
    Mono<Chunk> indexChunk(ChunkInput input);
    Mono<BatchIndexResult> indexBatch(BatchInput input);
    
    // Updates
    Mono<Node> updateNode(UUID nodeId, Map<String, Object> properties);
    Mono<Edge> updateEdge(UUID edgeId, Map<String, Object> properties);
    
    // Deletions
    Mono<Void> deleteNode(UUID nodeId, boolean cascade);
    Mono<Void> deleteEdge(UUID edgeId);
    Mono<Void> deleteChunk(UUID chunkId);
    
    // Statistics
    Mono<IndexStats> getStatistics();
}
```

##### 3.3 Indexer Implementation
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/service/KnowledgeIndexerImpl.java`

```java
@Service
public class KnowledgeIndexerImpl implements KnowledgeIndexer {
    
    private final NodeRepository nodeRepository;
    private final EdgeRepository edgeRepository;
    private final ChunkRepository chunkRepository;
    private final RelationTypeRepository relationTypeRepository;
    private final InMemoryKnowledgeGraph memoryGraph;
    private final EmbeddingService embeddingService;
    
    @Override
    @Transactional
    public Mono<Node> indexNode(NodeInput input) {
        return Mono.fromCallable(() -> input.toEntity())
            // 1. Save to database
            .flatMap(nodeRepository::save)
            // 2. Generate embedding if needed
            .flatMap(node -> generateEmbeddingIfNeeded(node))
            // 3. Add to in-memory graph
            .doOnNext(node -> memoryGraph.addNode(node))
            .doOnError(e -> log.error("Failed to index node", e));
    }
    
    @Override
    @Transactional
    public Mono<Edge> indexEdge(EdgeInput input) {
        return validateEdge(input)
            .flatMap(edge -> edgeRepository.save(edge))
            .doOnNext(edge -> memoryGraph.addEdge(edge));
    }
    
    // ... other methods
    
    private Mono<Node> generateEmbeddingIfNeeded(Node node) {
        if (node.getVectorizableContent() != null) {
            return embeddingService.generateEmbedding(node.getVectorizableContent())
                .flatMap(embedding -> createChunk(node, embedding));
        }
        return Mono.just(node);
    }
}
```

##### 3.4 Embedding Service (Stub)
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/service/EmbeddingService.java`

```java
@Service
public class EmbeddingService {
    
    private final EmbeddingClient embeddingClient;  // Spring AI
    
    public Mono<float[]> generateEmbedding(String text) {
        // Use Spring AI embedding client
        return Mono.fromCallable(() -> 
            embeddingClient.embed(text).getOutput()
        );
    }
    
    public Mono<List<float[]>> generateEmbeddings(List<String> texts) {
        return Flux.fromIterable(texts)
            .flatMap(this::generateEmbedding)
            .collectList();
    }
}
```

##### 3.5 Result DTOs
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/IndexResult.java`

```java
public record IndexResult(
    int nodesIndexed,
    int edgesIndexed,
    int chunksIndexed,
    long durationMs,
    List<String> errors
) {}
```

**Tests:** `KnowledgeIndexerImplTest.java`
- Test node indexing (DB + memory graph)
- Test edge indexing with validation
- Test batch indexing
- Test update operations
- Test delete with cascade
- Test error handling
- Mock embedding service
- **Coverage Target:** 60%

#### **Phase 3 Success Criteria**
- ✅ Indexer interface fully implemented
- ✅ Dual persistence working (DB + memory)
- ✅ Embedding generation integrated
- ✅ Transactional operations working
- ✅ Test coverage: 60%+ for indexer
- ✅ Performance: <100ms per node index

---

### **Phase 4: Knowledge Retriever Service** (Week 4)

#### **Objective**
Implement the `KnowledgeRetriever` interface with intelligent 3-level fallback search.

#### **Deliverables**

##### 4.1 Retriever Interface
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/service/KnowledgeRetriever.java`

```java
public interface KnowledgeRetriever {
    
    // Basic retrieval
    Mono<Node> findNode(UUID id);
    Flux<Node> findNodesByLabel(String label);
    Flux<Node> findNodesByProperty(String propertyPath, Object value);
    
    // Graph navigation
    Flux<Node> getParents(UUID nodeId);
    Flux<Node> getChildren(UUID nodeId);
    Flux<Node> getSiblings(UUID nodeId);
    Flux<Node> getNeighbors(UUID nodeId, int depth);
    
    // Path finding
    Mono<GraphPathResult> findPath(UUID fromId, UUID toId);
    Flux<GraphPathResult> findAllPaths(UUID fromId, UUID toId, int maxDepth);
    
    // Context extraction
    Mono<ReasoningContext> extractContext(Set<UUID> startNodeIds, GraphTraversal traversal);
    
    // Intelligent search (main entry point)
    Mono<SearchResult> retrieve(RetrievalRequest request);
    
    // Direct searches
    Flux<RankedChunk> vectorSearch(String query, int topK);
    Flux<RankedChunk> fullTextSearch(String query, int topK);
}
```

##### 4.2 Request/Response DTOs
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/RetrievalRequest.java`

```java
public record RetrievalRequest(
    GraphQuery graphQuery,
    String query,
    int maxTokenBudget
) {
    public static Builder builder() { return new Builder(); }
}
```

**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/GraphQuery.java`

```java
public record GraphQuery(
    List<ResolutionTarget> targets,
    TraversalHint traversal
) {}
```

**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/ResolutionTarget.java`

```java
public record ResolutionTarget(
    String description,
    String typeHint,
    Map<String, Object> properties
) {}
```

**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/TraversalHint.java`

```java
public record TraversalHint(
    int maxDepth,
    List<String> relationTypes,
    Direction direction
) {}
```

**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/ContextResponse.java`

```java
public record ContextResponse(
    Set<Node> relatedNodes,
    Set<Edge> relatedEdges,
    Set<Chunk> relatedChunks,
    long durationMs
) {}
```

##### 4.3 Retriever Implementation
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/service/KnowledgeRetrieverImpl.java`

```java
@Service
public class KnowledgeRetrieverImpl implements KnowledgeRetriever {
    
    private final InMemoryKnowledgeGraph memoryGraph;
    private final ChunkRepository chunkRepository;
    private final EmbeddingService embeddingService;
    
    @Override
    public Mono<RetrievalResult> retrieve(RetrievalRequest request) {
        long start = System.currentTimeMillis();
        
        // Step 1: Resolve Entry Points (Vector-First)
        return resolveEntryPoints(request.graphQuery())
            // Step 2: Extract context from graph
            .flatMap(startNodeIds -> extractContextIfNeeded(startNodeIds, request))
            // Step 3: Try hybrid search
            .flatMap(context -> tryHybridSearch(context, request))
            // Step 4: Fallback to pure vector search if needed
            .switchIfEmpty(fallbackToVectorIfNeeded(null, request))
            .flatMap(result -> {
                 if (result.isEmpty()) return fallbackToVectorIfNeeded(result, request);
                 return Mono.just(result);
            })
            // Step 5: Enrich with timing
            .map(result -> enrichWithTiming(result, start));
    }
    
    private Mono<Set<UUID>> resolveEntryPoints(GraphQuery query) {
        if (query == null || query.targets() == null) return Mono.just(Set.of());
        
        return Flux.fromIterable(query.targets())
            .flatMap(target -> {
                // Vector search for node content matching description
                return embeddingService.embed(target.description())
                    .flatMapMany(emb -> chunkRepository.findTopKSimilarPg(emb, 3)) // Top 3 matches
                    .map(Chunk::getLinkedNodeId) // Get linked node
                    .filter(Objects::nonNull);
            })
            .collect(Collectors.toSet());
    }
    
    private Mono<Optional<ReasoningContext>> extractContextIfNeeded(Set<UUID> startIds, RetrievalRequest req) {
        if (startIds.isEmpty()) {
            return Mono.just(Optional.empty());
        }
        return extractContext(startIds, req.graphQuery().traversal())
            .map(Optional::of);
    }
    
    private Mono<SearchResult> tryHybridSearch(Optional<ReasoningContext> ctx, 
                                              RetrievalRequest req) {
        if (ctx.isEmpty()) {
            return vectorSearch(req.query(), req.topK())
                .collectList()
                .map(chunks -> new SearchResult(chunks, SearchStrategy.VECTOR, 
                     null, req.query(), 0, Map.of()));
        }
        
        // Get chunk IDs linked to nodes in context
        Set<UUID> contextChunkIds = ctx.get().relatedNodes().stream()
            .map(Node::getId)
            .collect(Collectors.toSet());
        
        // Vector search constrained to these chunks
        return embeddingService.generateEmbedding(req.query())
            .flatMapMany(embedding -> vectorSearchFiltered(embedding, contextChunkIds, req.topK()))
            .collectList()
            .map(chunks -> new SearchResult(chunks, SearchStrategy.HYBRID,
                 ctx.get(), req.query(), 0, Map.of()));
    }
    
    // ... fallback methods
}
```

##### 4.4 Ranked Chunk DTO
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/dto/RankedChunk.java`

```java
public record RankedChunk(
    Chunk chunk,
    double score,
    Map<String, Object> explanation
) implements Comparable<RankedChunk> {
    
    @Override
    public int compareTo(RankedChunk other) {
        return Double.compare(other.score, this.score); // Descending
    }
}

##### 4.5 Context Assembler (New)
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/service/ContextAssembler.java`

```java
@Component
public class ContextAssembler {
    public String assemble(RetrievalResult result, int maxTokenBudget);
}
```
```

**Tests:** `KnowledgeRetrieverImplTest.java`
- Test basic retrieval (findNode, findByLabel)
- Test graph navigation (parents, children, siblings)
- Test context extraction with BFS
- Test hybrid search
- Test fallback to vector search
- Test fallback to BM25
- Test path finding
- Mock embedding service and repositories
- **Coverage Target:** 60%

#### **Phase 4 Success Criteria**
- ✅ Retriever interface fully implemented
- ✅ 3-level fallback working correctly
- ✅ Context extraction with graph traversal
- ✅ Test coverage: 60%+ for retriever
- ✅ Performance: <200ms for hybrid search

---

### **Phase 5: Configuration & Auto-Configuration** (Week 5)

#### **Objective**
Implement proper Spring Boot configuration binding and auto-configuration.

#### **Deliverables**

##### 5.1 Configuration Properties
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/config/CefProperties.java`

```java
@ConfigurationProperties(prefix = "cef")
public class CefProperties {
    
    private Storage storage = new Storage();
    private Graph graph = new Graph();
    private Embedding embedding = new Embedding();
    private Llm llm = new Llm();
    private Search search = new Search();
    
    // Nested classes
    public static class Storage {
        private String type = "duckdb";
        private Connection connection = new Connection();
        private Schemas schemas = new Schemas();
        
        public static class Connection {
            private String url;
            private String username;
            private String password;
            // getters/setters
        }
        
        public static class Schemas {
            private String graph = "cef_graph";
            private String vector = "cef_vector";
            // getters/setters
        }
        // getters/setters
    }
    
    public static class Graph {
        private boolean preloadOnStartup = true;
        private int maxNodes = 100000;
        private int maxEdges = 500000;
        // getters/setters
    }
    
    public static class Embedding {
        private String provider = "ollama";
        private String model = "nomic-embed-text";
        private int dimension = 768;
        private String baseUrl = "http://localhost:11434";
        // getters/setters
    }
    
    public static class Search {
        private int defaultDepth = 2;
        private int defaultTopK = 10;
        private int minResultsThreshold = 3;
        // getters/setters
    }
    
    // getters/setters
}
```

##### 5.2 Auto Configuration
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/config/CefAutoConfiguration.java`

```java
@Configuration
@EnableConfigurationProperties(CefProperties.class)
@ConditionalOnProperty(prefix = "cef", name = "enabled", matchIfMissing = true)
public class CefAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public InMemoryKnowledgeGraph inMemoryKnowledgeGraph() {
        return new InMemoryKnowledgeGraph();
    }
    
    @Bean
    @ConditionalOnMissingBean
    public KnowledgeIndexer knowledgeIndexer(
        NodeRepository nodeRepository,
        EdgeRepository edgeRepository,
        ChunkRepository chunkRepository,
        RelationTypeRepository relationTypeRepository,
        InMemoryKnowledgeGraph memoryGraph,
        EmbeddingService embeddingService
    ) {
        return new KnowledgeIndexerImpl(
            nodeRepository, edgeRepository, chunkRepository,
            relationTypeRepository, memoryGraph, embeddingService
        );
    }
    
    @Bean
    @ConditionalOnMissingBean
    public KnowledgeRetriever knowledgeRetriever(
        InMemoryKnowledgeGraph memoryGraph,
        ChunkRepository chunkRepository,
        EmbeddingService embeddingService
    ) {
        return new KnowledgeRetrieverImpl(memoryGraph, chunkRepository, embeddingService);
    }
    
    @Bean
    @ConditionalOnMissingBean
    public EmbeddingService embeddingService(EmbeddingClient embeddingClient) {
        return new EmbeddingService(embeddingClient);
    }
}
```

**File:** `cef-framework/src/main/resources/META-INF/spring.factories`

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.ddse.ml.cef.config.CefAutoConfiguration
```

##### 5.3 Database Configuration
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/config/DatabaseConfiguration.java`

```java
@Configuration
public class DatabaseConfiguration {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.r2dbc")
    public ConnectionFactoryOptions connectionFactoryOptions() {
        return ConnectionFactoryOptions.builder().build();
    }
    
    @Bean
    public ConnectionFactoryInitializer initializer(ConnectionFactory connectionFactory) {
        ConnectionFactoryInitializer initializer = new ConnectionFactoryInitializer();
        initializer.setConnectionFactory(connectionFactory);
        
        CompositeDatabasePopulator populator = new CompositeDatabasePopulator();
        populator.addPopulators(new ResourceDatabasePopulator(
            new ClassPathResource("schema-postgresql.sql")
        ));
        initializer.setDatabasePopulator(populator);
        
        return initializer;
    }
}
```

**Tests:** `CefAutoConfigurationTest.java`
- Test auto-configuration loads
- Test beans created conditionally
- Test configuration properties binding
- **Coverage Target:** 50%

#### **Phase 5 Success Criteria**
- ✅ Configuration properties bound from YAML
- ✅ Auto-configuration working
- ✅ Schema initialization on startup
- ✅ Conditional bean creation working
- ✅ Test coverage: 50%+ for configuration

---

### **Phase 6: Parser System** (Week 6)

#### **Objective**
Implement parser infrastructure. Simple formats use standard libraries (YAML/CSV/JSON). ANTLR optional for complex documents (structured PDFs).

#### **Deliverables**

**Key Decision:** ANTLR is OPTIONAL - only for complex custom formats (10-50 page structured PDFs, proprietary formats). Use SnakeYAML/Jackson/OpenCSV for YAML/JSON/CSV.

**ANTLR Use Cases:**
- Medical lab reports with 10-50 pages, specific section structure
- Legal contracts with defined format
- Custom domain-specific languages

**Standard Library Use Cases:**
- YAML/JSON/CSV files (SnakeYAML, Jackson, OpenCSV)
- Plain text documents
- HTML/XML (Jsoup, standard parsers)

##### 6.1 Parser Base Classes
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/parser/AbstractParser.java`

```java
public abstract class AbstractParser<T extends ParsedData> {
    
    protected final Logger log = LoggerFactory.getLogger(getClass());
    
    public abstract List<String> getSupportedExtensions();
    public abstract int getOrder();
    
    public abstract T parse(InputStream input, ParseContext context) 
        throws ParseException;
    
    public void validate(T data) throws ValidationException {
        // Default: no validation
    }
    
    public abstract List<NodeInput> extractNodes(T data);
    public abstract List<EdgeInput> extractEdges(T data);
    public abstract List<ChunkInput> extractChunks(T data);
}
```

**File:** `cef-framework/src/main/java/org/ddse/ml/cef/parser/ParsedData.java`

```java
public abstract class ParsedData {
    private final String source;
    private final String format;
    private final Map<String, Object> metadata;
    private final Instant parsedAt;
    
    protected ParsedData(String source, String format) {
        this.source = source;
        this.format = format;
        this.metadata = new HashMap<>();
        this.parsedAt = Instant.now();
    }
    
    // getters
}
```

**File:** `cef-framework/src/main/java/org/ddse/ml/cef/parser/ParseContext.java`

```java
public record ParseContext(
    String sourcePath,
    String fileName,
    String extension,
    Map<String, Object> metadata
) {}
```

##### 6.2 Simple YAML Parser
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/parser/YamlParser.java`

```java
@Component
public class YamlParser extends AbstractParser<YamlParsedData> {
    
    private final Yaml yaml = new Yaml();
    
    @Override
    public List<String> getSupportedExtensions() {
        return List.of(".yml", ".yaml");
    }
    
    @Override
    public int getOrder() {
        return 100;
    }
    
    @Override
    public YamlParsedData parse(InputStream input, ParseContext context) {
        Map<String, Object> data = yaml.load(input);
        return new YamlParsedData(context.sourcePath(), data);
    }
    
    @Override
    public List<NodeInput> extractNodes(YamlParsedData data) {
        // Look for "nodes" key in YAML
        List<Map<String, Object>> nodesList = 
            (List<Map<String, Object>>) data.getRawData().get("nodes");
        
        if (nodesList == null) return List.of();
        
        return nodesList.stream()
            .map(this::mapToNodeInput)
            .toList();
    }
    
    private NodeInput mapToNodeInput(Map<String, Object> map) {
        return new NodeInput(
            map.containsKey("id") ? UUID.fromString((String) map.get("id")) : null,
            (String) map.get("label"),
            (Map<String, Object>) map.get("properties"),
            (String) map.get("content")
        );
    }
    
    // Similar for edges and chunks
}
```

##### 6.3 Parser Factory
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/parser/ParserFactory.java`

```java
@Component
public class ParserFactory {
    
    private final List<AbstractParser<?>> parsers = new CopyOnWriteArrayList<>();
    private final Logger log = LoggerFactory.getLogger(ParserFactory.class);
    
    @Autowired(required = false)
    public void registerParsers(List<AbstractParser<?>> parserList) {
        parsers.addAll(parserList);
        parsers.sort(Comparator.comparingInt(AbstractParser::getOrder));
        
        log.info("Registered {} parsers", parsers.size());
    }
    
    public Optional<AbstractParser<?>> findParser(String extension) {
        return parsers.stream()
            .filter(p -> p.getSupportedExtensions().contains(extension))
            .findFirst();
    }
    
    public ParsedData parse(InputStream input, ParseContext context) 
        throws ParseException {
        
        AbstractParser<?> parser = findParser(context.extension())
            .orElseThrow(() -> new ParseException(
                "No parser for extension: " + context.extension()));
        
        return parser.parse(input, context);
    }
}
```

**Tests:** `ParserFactoryTest.java`, `YamlParserTest.java`
- Test parser registration
- Test order-based selection
- Test YAML parsing with nodes/edges/chunks
- **Coverage Target:** 55%

#### **Phase 6 Success Criteria**
- ✅ Parser infrastructure complete
- ✅ YAML parser working
- ✅ Parser factory with order-based selection
- ✅ Test coverage: 55%+ for parser system
- ✅ Users can register custom parsers

---

### **Phase 7: DataSource Adapters (Minimal)** (Week 7)

#### **Objective**
Implement basic file system data source (defer S3/MinIO).

#### **Deliverables**

##### 7.1 DataSource Interface
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/datasource/DataSource.java`

```java
public interface DataSource extends AutoCloseable {
    
    Flux<ResourceInfo> listResources();
    Flux<ResourceInfo> listResources(String pattern);
    Mono<InputStream> getInputStream(String resourcePath);
    Mono<Boolean> exists(String resourcePath);
    Mono<ResourceInfo> getResourceInfo(String resourcePath);
    
    @Override
    void close();
}
```

##### 7.2 ResourceInfo DTO
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/datasource/ResourceInfo.java`

```java
public record ResourceInfo(
    String path,
    String name,
    String extension,
    long size,
    Instant lastModified,
    String contentType,
    Map<String, Object> metadata
) {}
```

##### 7.3 FileSystem DataSource
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/datasource/FileSystemDataSource.java`

```java
@Component
public class FileSystemDataSource implements DataSource {
    
    private final Path rootPath;
    
    public FileSystemDataSource(String rootPath) {
        this.rootPath = Paths.get(rootPath);
        if (!Files.exists(this.rootPath)) {
            throw new IllegalArgumentException("Root path does not exist: " + rootPath);
        }
    }
    
    @Override
    public Flux<ResourceInfo> listResources() {
        try {
            return Flux.fromStream(Files.walk(rootPath)
                .filter(Files::isRegularFile)
                .map(this::toResourceInfo));
        } catch (IOException e) {
            return Flux.error(new DataSourceException("Failed to list resources", e));
        }
    }
    
    @Override
    public Mono<InputStream> getInputStream(String resourcePath) {
        return Mono.fromCallable(() -> {
            Path fullPath = rootPath.resolve(resourcePath);
            return Files.newInputStream(fullPath);
        });
    }
    
    // ... other methods
    
    private ResourceInfo toResourceInfo(Path path) {
        try {
            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
            String fileName = path.getFileName().toString();
            String extension = getExtension(fileName);
            
            return new ResourceInfo(
                rootPath.relativize(path).toString(),
                fileName,
                extension,
                attrs.size(),
                attrs.lastModifiedTime().toInstant(),
                Files.probeContentType(path),
                Map.of()
            );
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}
```

##### 7.4 Integration with Indexer
Update `KnowledgeIndexerImpl.fullIndex(DataSource)`:

```java
@Override
public Mono<IndexResult> fullIndex(DataSource dataSource) {
    long start = System.currentTimeMillis();
    AtomicInteger nodeCount = new AtomicInteger();
    AtomicInteger edgeCount = new AtomicInteger();
    AtomicInteger chunkCount = new AtomicInteger();
    
    return dataSource.listResources()
        .flatMap(resourceInfo -> processResource(resourceInfo, dataSource))
        .doOnNext(result -> {
            nodeCount.addAndGet(result.nodes().size());
            edgeCount.addAndGet(result.edges().size());
            chunkCount.addAndGet(result.chunks().size());
        })
        .then(Mono.fromCallable(() -> new IndexResult(
            nodeCount.get(),
            edgeCount.get(),
            chunkCount.get(),
            System.currentTimeMillis() - start,
            List.of()
        )));
}

private Mono<ParseResult> processResource(ResourceInfo info, DataSource dataSource) {
    return dataSource.getInputStream(info.path())
        .flatMap(inputStream -> {
            ParseContext context = new ParseContext(
                info.path(), info.name(), info.extension(), info.metadata()
            );
            
            try {
                ParsedData parsed = parserFactory.parse(inputStream, context);
                
                List<NodeInput> nodes = parser.extractNodes(parsed);
                List<EdgeInput> edges = parser.extractEdges(parsed);
                List<ChunkInput> chunks = parser.extractChunks(parsed);
                
                return indexBatch(new BatchInput(nodes, edges, chunks))
                    .map(result -> new ParseResult(nodes, edges, chunks));
            } catch (ParseException e) {
                return Mono.error(e);
            }
        });
}
```

**Tests:** `FileSystemDataSourceTest.java`
- Test listing files
- Test pattern matching
- Test reading files
- Test resource info extraction
- **Coverage Target:** 60%

#### **Phase 7 Success Criteria**
- ✅ FileSystem data source working
- ✅ Integration with parser factory
- ✅ fullIndex from data source working
- ✅ Test coverage: 60%+ for datasource
- ✅ Can index directory of YAML files

---

### **Phase 8: Integration Tests & Documentation** (Week 8)

#### **Objective**
Add comprehensive integration tests and complete documentation.

#### **Deliverables**

##### 8.1 Integration Tests
**File:** `cef-framework/src/test/java/org/ddse/ml/cef/integration/CefFrameworkIntegrationTest.java`

```java
@SpringBootTest
@Testcontainers
class CefFrameworkIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("cef_test")
        .withUsername("test")
        .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.r2dbc.url", () -> 
            "r2dbc:postgresql://" + postgres.getHost() + ":" + postgres.getFirstMappedPort() + 
            "/cef_test");
        registry.add("spring.r2dbc.username", postgres::getUsername);
        registry.add("spring.r2dbc.password", postgres::getPassword);
    }
    
    @Autowired
    private KnowledgeIndexer indexer;
    
    @Autowired
    private KnowledgeRetriever retriever;
    
    @Test
    void testFullIndexingAndRetrieval() {
        // Given: Initialize framework
        List<NodeInput> rootNodes = List.of(
            new NodeInput(null, "Root", Map.of("type", "root"), null)
        );
        
        List<RelationType> relationTypes = List.of(
            new RelationType("IS_A", RelationSemantics.CLASSIFICATION, false, "Classification")
        );
        
        StepVerifier.create(indexer.initialize(rootNodes, relationTypes))
            .verifyComplete();
        
        // When: Index nodes and edges
        NodeInput patientInput = new NodeInput(
            null, "Patient", 
            Map.of("name", "John Doe", "age", 45),
            "Patient with diabetes"
        );
        
        Mono<Node> patientMono = indexer.indexNode(patientInput);
        
        // Then: Can retrieve
        StepVerifier.create(patientMono)
            .assertNext(node -> {
                assertNotNull(node.getId());
                assertEquals("Patient", node.getLabel());
            })
            .verifyComplete();
        
        // And: Can search
        RetrievalRequest request = RetrievalRequest.builder()
            .query("diabetes")
            .topK(10)
            .build();
        
        StepVerifier.create(retriever.retrieve(request))
            .assertNext(result -> {
                assertFalse(result.results().isEmpty());
            })
            .verifyComplete();
    }
    
    @Test
    void testGraphTraversal() {
        // Test BFS traversal, parent/child relationships
    }
    
    @Test
    void testFullIndexFromDataSource() {
        // Test loading from filesystem
    }
}
```

##### 8.2 JavaDoc Documentation
Add comprehensive JavaDoc to all public APIs:
- All interfaces (`KnowledgeIndexer`, `KnowledgeRetriever`)
- All public methods
- All DTOs
- Configuration properties

##### 8.3 README for Framework
**File:** `cef-framework/README.md`

```markdown
# CEF Framework

Domain-agnostic context engineering framework for LLM applications.

## Features
- Reactive knowledge graph indexing (Spring Data R2DBC)
- JGraphT in-memory graph with O(1) lookups
- Intelligent 3-level search (Hybrid → Vector → BM25)
- Extensible parser system
- Database agnostic (PostgreSQL, DuckDB)

## Quick Start

### 1. Add Dependency
```xml
<dependency>
    <groupId>org.ddse.ml</groupId>
    <artifactId>cef-framework</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>
```

### 2. Configure
```yaml
cef:
  storage:
    type: postgresql
  embedding:
    provider: ollama
```

### 3. Use
```java
@Autowired
private KnowledgeIndexer indexer;

// Index a node
NodeInput input = new NodeInput(null, "Product", 
    Map.of("name", "Laptop"), "High-performance laptop");
    
Mono<Node> node = indexer.indexNode(input);
```

---

### **Phase 9: LLM Client Integration** (Week 9)

#### **Objective**
Implement abstraction layer for LLM providers (Ollama, vLLM, OpenAI).

#### **Deliverables**

##### 9.1 LLM Client Interface
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/llm/LLMClient.java`

```java
public interface LLMClient {
    Mono<String> complete(String prompt);
    Mono<String> chat(List<ChatMessage> messages);
    Flux<String> streamChat(List<ChatMessage> messages);
}
```

##### 9.2 Ollama Implementation
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/llm/ollama/OllamaClient.java`

```java
@Component
public class OllamaClient implements LLMClient {
    private final WebClient webClient;
    
    // Implementation using Ollama API
}
```

##### 9.3 Client Factory
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/llm/LLMClientFactory.java`

```java
@Component
public class LLMClientFactory {
    public LLMClient createClient(String provider) {
        // Return appropriate client
    }
}
```

#### **Phase 9 Success Criteria**
- ✅ LLMClient interface defined
- ✅ Ollama integration working
- ✅ Streaming support
- ✅ Test coverage: 60%

---

### **Phase 10: Context Provider Tool** (Week 10)

#### **Objective**
Implement the `DefaultContextProviderTool` that exposes the `KnowledgeRetriever` to the LLM via a tool interface.

#### **Deliverables**

##### 10.1 Tool Implementation
**File:** `cef-framework/src/main/java/org/ddse/ml/cef/tool/DefaultContextProviderTool.java`

```java
@Component
public class DefaultContextProviderTool {
    
    private final KnowledgeRetriever retriever;
    private final ContextAssembler assembler;
    
    @Tool(name = "retrieve_knowledge", description = """
        Retrieves knowledge from the graph.
        Use this tool to find information about specific entities or concepts.
        
        Parameters:
        - targets: List of entities to resolve (e.g., "Patient John Doe", "Diabetes Diagnosis")
        - traversal: Hints for graph traversal (depth, relation types)
        - query: Natural language query for hybrid search
        """)
    public String retrieveKnowledge(GraphQuery query, String nlQuery) {
        RetrievalRequest request = new RetrievalRequest(query, nlQuery, 2000);
        
        RetrievalResult result = retriever.retrieve(request).block();
        return assembler.assemble(result, 2000);
    }
}
```

#### **Phase 10 Success Criteria**
- ✅ Tool interface correctly defined with schema hints
- ✅ Integration with KnowledgeRetriever
- ✅ Context assembly working
- ✅ End-to-end test with mocked LLM

## Documentation
See [ADR-002](../docs/ADR-002.md) for architecture details.
````
