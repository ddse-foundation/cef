"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[346],{5440:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"user-guide","title":"CEF User Guide: ORM for Context Engineering","description":"Version: beta-0.5","source":"@site/docs/user-guide.md","sourceDirName":".","slug":"/user-guide","permalink":"/cef/docs/user-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/ddse-foundation/cef/tree/main/site/docs/user-guide.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Context Engineering Framework (CEF) - Architecture","permalink":"/cef/docs/architecture"},"next":{"title":"Hands-On: Build a Knowledge Model in 30 Minutes","permalink":"/cef/docs/tutorials/build-your-first-model"}}');var r=t(4848),o=t(8453);const a={},s="CEF User Guide: ORM for Context Engineering",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Core Philosophy",id:"core-philosophy",level:3},{value:"When to Use CEF",id:"when-to-use-cef",level:3},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Quick Integration",id:"quick-integration",level:2},{value:"Step 1: Add Dependency",id:"step-1-add-dependency",level:3},{value:"Step 2: Configure Application",id:"step-2-configure-application",level:3},{value:"Step 3: Initialize Knowledge Model",id:"step-3-initialize-knowledge-model",level:3},{value:"Step 4: Use ORM Services",id:"step-4-use-orm-services",level:3},{value:"Defining Knowledge Models",id:"defining-knowledge-models",level:2},{value:"Philosophy: Knowledge Model vs Data Model",id:"philosophy-knowledge-model-vs-data-model",level:3},{value:"Mapping Your Domain",id:"mapping-your-domain",level:3},{value:"1. Identify Entities (Nodes)",id:"1-identify-entities-nodes",level:4},{value:"2. Define Relationships (Edges)",id:"2-define-relationships-edges",level:4},{value:"3. Vectorizable Content",id:"3-vectorizable-content",level:4},{value:"Setting Up ORM Layer",id:"setting-up-orm-layer",level:2},{value:"1. Repository Pattern (Recommended)",id:"1-repository-pattern-recommended",level:3},{value:"2. Service Layer Pattern",id:"2-service-layer-pattern",level:3},{value:"3. Lifecycle Hooks (Like JPA Callbacks)",id:"3-lifecycle-hooks-like-jpa-callbacks",level:3},{value:"Indexing Knowledge",id:"indexing-knowledge",level:2},{value:"Batch Indexing (Like Hibernate&#39;s StatelessSession)",id:"batch-indexing-like-hibernates-statelesssession",level:3},{value:"Incremental Updates (Like JPA Merge)",id:"incremental-updates-like-jpa-merge",level:3},{value:"Retrieving Context",id:"retrieving-context",level:2},{value:"Basic Queries (Like JPQL)",id:"basic-queries-like-jpql",level:3},{value:"Complex Context Retrieval",id:"complex-context-retrieval",level:3},{value:"Automatic Fallback",id:"automatic-fallback",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"1. Caching Strategy (Planned for v0.6)",id:"1-caching-strategy-planned-for-v06",level:3},{value:"2. Multi-Tenancy (Planned for v0.6)",id:"2-multi-tenancy-planned-for-v06",level:3},{value:"3. Validation Framework (Like Bean Validation)",id:"3-validation-framework-like-bean-validation",level:3},{value:"4. Schema Evolution (Like Flyway/Liquibase)",id:"4-schema-evolution-like-flywayliquibase",level:3},{value:"Production Deployment",id:"production-deployment",level:2},{value:"1. Monitoring &amp; Observability",id:"1-monitoring--observability",level:3},{value:"2. Health Checks",id:"2-health-checks",level:3},{value:"3. Performance Tuning",id:"3-performance-tuning",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Issue 1: Slow Retrieval",id:"issue-1-slow-retrieval",level:4},{value:"Issue 2: Out of Memory (JGraphT)",id:"issue-2-out-of-memory-jgrapht",level:4},{value:"Issue 3: Embedding Generation Slow",id:"issue-3-embedding-generation-slow",level:4},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"cef-user-guide-orm-for-context-engineering",children:"CEF User Guide: ORM for Context Engineering"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Version:"})," beta-0.5",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Date:"})," November 27, 2025",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Audience:"})," Java Developers Integrating CEF"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["Welcome to the Context Engineering Framework (CEF) - the ",(0,r.jsx)(n.strong,{children:"Hibernate for LLM Context"}),". This guide helps you integrate CEF into your application as an ORM layer for knowledge models, just as you would integrate Hibernate for transactional data models."]}),"\n",(0,r.jsx)(n.h3,{id:"core-philosophy",children:"Core Philosophy"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Traditional ORM (Hibernate/JPA)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Define entities (",(0,r.jsx)(n.code,{children:"@Entity"}),", ",(0,r.jsx)(n.code,{children:"@Table"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Map relationships (",(0,r.jsx)(n.code,{children:"@OneToMany"}),", ",(0,r.jsx)(n.code,{children:"@ManyToOne"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Persist/query data (",(0,r.jsx)(n.code,{children:"EntityManager.persist()"}),", ",(0,r.jsx)(n.code,{children:"em.find()"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Purpose: Manage ",(0,r.jsx)(n.strong,{children:"transactional data"})," (orders, users, products)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Knowledge ORM (CEF)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Define knowledge entities (",(0,r.jsx)(n.code,{children:"Node"}),", ",(0,r.jsx)(n.code,{children:"Edge"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Map semantic relationships (",(0,r.jsx)(n.code,{children:"RelationType"}),", ",(0,r.jsx)(n.code,{children:"RelationSemantics"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Index/retrieve context (",(0,r.jsx)(n.code,{children:"indexer.indexNode()"}),", ",(0,r.jsx)(n.code,{children:"retriever.retrieve()"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Purpose: Manage ",(0,r.jsx)(n.strong,{children:"knowledge models"})," for LLM context"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-cef",children:"When to Use CEF"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Use CEF"})," when your LLM needs:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Structured knowledge with relationships (not just documents)"}),"\n",(0,r.jsx)(n.li,{children:'Entity-aware retrieval ("John\'s medical history")'}),"\n",(0,r.jsx)(n.li,{children:'Multi-hop reasoning ("patients similar to John")'}),"\n",(0,r.jsx)(n.li,{children:"Domain-specific context assembly"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Don't Use CEF"})," if you only need:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple document search (use pure vector database)"}),"\n",(0,r.jsx)(n.li,{children:"Unstructured text without entities"}),"\n",(0,r.jsx)(n.li,{children:"One-shot question answering without context"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["API note (beta-0.5): The canonical types are ",(0,r.jsx)(n.code,{children:"Node"}),", ",(0,r.jsx)(n.code,{children:"Edge"}),", and ",(0,r.jsx)(n.code,{children:"Chunk"}),", plus ",(0,r.jsx)(n.code,{children:"RelationType(name, sourceLabel, targetLabel, semantics, directed)"})," with enum values ",(0,r.jsx)(n.code,{children:"HIERARCHICAL"}),", ",(0,r.jsx)(n.code,{children:"ASSOCIATIVE"}),", ",(0,r.jsx)(n.code,{children:"CAUSAL"}),", ",(0,r.jsx)(n.code,{children:"TEMPORAL"}),", ",(0,r.jsx)(n.code,{children:"SPATIAL"}),", and ",(0,r.jsx)(n.code,{children:"CUSTOM"}),". Some snippets below reflect earlier enum names; use the ",(0,r.jsx)(n.a,{href:"/cef/docs/tutorials/build-your-first-model",children:"Hands-On tutorial"})," for the exact code paths exercised by the tests."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#quick-integration",children:"Quick Integration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#defining-knowledge-models",children:"Defining Knowledge Models"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#setting-up-orm-layer",children:"Setting Up ORM Layer"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#indexing-knowledge",children:"Indexing Knowledge"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#retrieving-context",children:"Retrieving Context"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#advanced-patterns",children:"Advanced Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#production-deployment",children:"Production Deployment"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#troubleshooting",children:"Troubleshooting"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"quick-integration",children:"Quick Integration"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-add-dependency",children:"Step 1: Add Dependency"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>org.ddse.ml</groupId>\n    <artifactId>cef-framework</artifactId>\n    <version>0.1.0-SNAPSHOT</version>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-configure-application",children:"Step 2: Configure Application"}),"\n",(0,r.jsxs)(n.p,{children:["Create ",(0,r.jsx)(n.code,{children:"application.yml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"cef:\n  # Storage backends (like configuring Hibernate datasource)\n  graph:\n    store: jgrapht  # in-memory for &lt;100K entities\n    preload-on-startup: true\n  \n  vector:\n    store: postgres  # persistent semantic search\n    dimension: 768\n  \n  # Embedding provider (like configuring JPA dialect)\n  embedding:\n    provider: ollama\n    model: nomic-embed-text\n    base-url: http://localhost:11434\n\nspring:\n  # R2DBC connection (like JPA datasource)\n  r2dbc:\n    url: r2dbc:postgresql://localhost:5432/mydb\n    username: postgres\n    password: postgres\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-initialize-knowledge-model",children:"Step 3: Initialize Knowledge Model"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class KnowledgeModelConfig {\n    \n    @Autowired\n    private KnowledgeIndexer indexer;\n    \n    @PostConstruct\n    public void initializeKnowledgeModel() {\n        // Define relationship semantics (like @Entity mapping)\n        List<RelationType> relationTypes = List.of(\n            new RelationType("TREATS", RelationSemantics.ASSOCIATION, true, \n                "Doctor treats patient"),\n            new RelationType("HAS_CONDITION", RelationSemantics.ATTRIBUTION, false,\n                "Patient has medical condition"),\n            new RelationType("PRESCRIBED_MEDICATION", RelationSemantics.CAUSALITY, false,\n                "Patient prescribed medication")\n        );\n        \n        // Initialize framework (like EntityManagerFactory setup)\n        indexer.initialize(List.of(), relationTypes).block();\n        \n        log.info("Knowledge model initialized with {} relation types", \n            relationTypes.size());\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-use-orm-services",children:"Step 4: Use ORM Services"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class PatientService {\n    \n    @Autowired\n    private KnowledgeIndexer indexer;  // Like EntityManager\n    \n    @Autowired\n    private KnowledgeRetriever retriever;  // Like Repository\n    \n    public Mono<Node> createPatient(PatientDTO dto) {\n        // Similar to em.persist(entity)\n        NodeInput input = new NodeInput(\n            null,  // auto-generate ID\n            "Patient",\n            Map.of(\n                "name", dto.getName(),\n                "age", dto.getAge(),\n                "gender", dto.getGender()\n            ),\n            dto.getMedicalHistory()  // vectorizable content\n        );\n        \n        return indexer.indexNode(input);\n    }\n    \n    public Mono<SearchResult> findPatientContext(String patientName) {\n        // Similar to repository.findByName()\n        GraphQuery query = new GraphQuery(\n            "Find medical context for " + patientName,\n            List.of(new ResolutionTarget(patientName, "Patient", 1)),\n            new TraversalHint(List.of("HAS_CONDITION", "PRESCRIBED_MEDICATION"), 2, null),\n            null, null, null,\n            3, 10, true, 4000, 100, 100\n        );\n        \n        return retriever.retrieve(query);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"defining-knowledge-models",children:"Defining Knowledge Models"}),"\n",(0,r.jsx)(n.h3,{id:"philosophy-knowledge-model-vs-data-model",children:"Philosophy: Knowledge Model vs Data Model"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data Model"})," (Hibernate):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(name = "patients")\npublic class Patient {\n    @Id\n    private Long id;\n    \n    @Column\n    private String name;\n    \n    @ManyToOne\n    @JoinColumn(name = "doctor_id")\n    private Doctor treatingDoctor;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Knowledge Model"})," (CEF):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Framework provides primitives\npublic class Node {\n    UUID id;                        // Entity identifier\n    String label;                   // Type (like @Entity name)\n    Map<String, Object> properties; // Attributes (like @Column)\n    String vectorizableContent;     // Semantic content\n}\n\npublic class Edge {\n    UUID id;\n    String relationType;            // Relationship (like @ManyToOne)\n    UUID sourceNodeId;\n    UUID targetNodeId;\n}\n\n// You define semantics\npublic class RelationType {\n    String name;                    // "TREATS", "HAS_CONDITION"\n    RelationSemantics semantics;    // How framework understands it\n    boolean bidirectional;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"mapping-your-domain",children:"Mapping Your Domain"}),"\n",(0,r.jsx)(n.h4,{id:"1-identify-entities-nodes",children:"1. Identify Entities (Nodes)"}),"\n",(0,r.jsxs)(n.p,{children:["Map domain entities to ",(0,r.jsx)(n.code,{children:"Node"})," labels:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Medical Domain\n"Patient" \u2192 Node(label="Patient", properties={name, age, gender})\n"Doctor" \u2192 Node(label="Doctor", properties={name, specialization})\n"Condition" \u2192 Node(label="Condition", properties={name, icd10Code})\n"Medication" \u2192 Node(label="Medication", properties={name, dosage})\n\n// E-Commerce Domain\n"Product" \u2192 Node(label="Product", properties={name, price, category})\n"Customer" \u2192 Node(label="Customer", properties={name, email})\n"Order" \u2192 Node(label="Order", properties={orderDate, total})\n\n// Legal Domain\n"Case" \u2192 Node(label="Case", properties={caseNumber, court, year})\n"Statute" \u2192 Node(label="Statute", properties={code, title})\n"Precedent" \u2192 Node(label="Precedent", properties={citation, court})\n'})}),"\n",(0,r.jsx)(n.h4,{id:"2-define-relationships-edges",children:"2. Define Relationships (Edges)"}),"\n",(0,r.jsx)(n.p,{children:"Map relationships with semantic hints:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class DomainRelationships {\n    \n    public List<RelationType> medicalRelations() {\n        return List.of(\n            // Hierarchical relationships (parent-child)\n            new RelationType("IS_PART_OF", RelationSemantics.HIERARCHY, true,\n                "Organ is part of body system"),\n            \n            // Classification relationships (instance-class)\n            new RelationType("IS_TYPE_OF", RelationSemantics.CLASSIFICATION, false,\n                "Specific condition is type of general condition"),\n            \n            // Association relationships (peer-to-peer)\n            new RelationType("TREATS", RelationSemantics.ASSOCIATION, true,\n                "Doctor treats patient"),\n            \n            // Attribution relationships (has/owns)\n            new RelationType("HAS_CONDITION", RelationSemantics.ATTRIBUTION, false,\n                "Patient has condition"),\n            \n            // Causal relationships (cause-effect)\n            new RelationType("PRESCRIBED_MEDICATION", RelationSemantics.CAUSALITY, false,\n                "Treatment prescribed for condition"),\n            \n            // Temporal relationships (sequence)\n            new RelationType("FOLLOWS", RelationSemantics.TEMPORAL, false,\n                "Treatment follows diagnosis")\n        );\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why Semantics Matter:"}),"\nFramework uses ",(0,r.jsx)(n.code,{children:"RelationSemantics"})," to optimize traversal:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HIERARCHY"}),': Navigate parents/children (e.g., "get all sub-conditions")']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CLASSIFICATION"}),': Find sibling instances (e.g., "similar patients")']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ASSOCIATION"}),': Explore related entities (e.g., "doctor\'s patients")']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CAUSALITY"}),': Follow cause-effect chains (e.g., "condition \u2192 treatment")']}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"3-vectorizable-content",children:"3. Vectorizable Content"}),"\n",(0,r.jsxs)(n.p,{children:["Like defining ",(0,r.jsx)(n.code,{children:"@Lob"})," fields in JPA, specify what content should be semantically searchable:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Good vectorizable content\nNodeInput patient = new NodeInput(\n    null, "Patient",\n    Map.of("name", "John Doe", "age", 45),\n    // Rich textual description\n    "45-year-old male with history of type 2 diabetes, hypertension, " +\n    "and hyperlipidemia. Recently experienced chest pain and shortness of breath."\n);\n\n// Bad vectorizable content (too short/generic)\nNodeInput patient = new NodeInput(\n    null, "Patient",\n    Map.of("name", "John Doe"),\n    "Patient"  // Too generic, won\'t help retrieval\n);\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"setting-up-orm-layer",children:"Setting Up ORM Layer"}),"\n",(0,r.jsx)(n.h3,{id:"1-repository-pattern-recommended",children:"1. Repository Pattern (Recommended)"}),"\n",(0,r.jsx)(n.p,{children:"Create domain-specific facades over CEF ORM:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Repository\npublic class PatientKnowledgeRepository {\n    \n    private final KnowledgeIndexer indexer;\n    private final KnowledgeRetriever retriever;\n    \n    // CREATE\n    public Mono<UUID> createPatient(PatientDTO dto) {\n        NodeInput node = toNodeInput(dto);\n        return indexer.indexNode(node)\n            .map(Node::getId);\n    }\n    \n    // READ - by ID\n    public Mono<PatientDTO> findPatientById(UUID id) {\n        return retriever.findNode(id)\n            .map(this::toDTO);\n    }\n    \n    // READ - by property\n    public Flux<PatientDTO> findPatientsByAge(int age) {\n        return retriever.findNodesByProperty("age", age)\n            .map(this::toDTO);\n    }\n    \n    // READ - with relationships\n    public Mono<PatientContext> findPatientWithConditions(UUID patientId) {\n        return retriever.getChildren(patientId)  // Follow HAS_CONDITION edges\n            .collectList()\n            .map(conditions -> new PatientContext(patientId, conditions));\n    }\n    \n    // UPDATE\n    public Mono<Node> updatePatient(UUID id, Map<String, Object> updates) {\n        return indexer.updateNode(id, updates);\n    }\n    \n    // DELETE\n    public Mono<Void> deletePatient(UUID id) {\n        return indexer.deleteNode(id, true);  // cascade edges\n    }\n    \n    // Complex Query - like JPQL\n    public Mono<SearchResult> findPatientsWithSimilarConditions(UUID patientId) {\n        // 1. Get patient\'s conditions\n        return retriever.getChildren(patientId)\n            // 2. Find patients with same conditions (siblings in graph)\n            .flatMap(condition -> retriever.getSiblings(condition.getId()))\n            .distinct()\n            // 3. Assemble into SearchResult\n            .collectList()\n            .map(this::toSearchResult);\n    }\n    \n    // Helper methods\n    private NodeInput toNodeInput(PatientDTO dto) {\n        return new NodeInput(\n            dto.getId(),\n            "Patient",\n            Map.of(\n                "name", dto.getName(),\n                "age", dto.getAge(),\n                "gender", dto.getGender()\n            ),\n            dto.getMedicalHistory()\n        );\n    }\n    \n    private PatientDTO toDTO(Node node) {\n        return new PatientDTO(\n            node.getId(),\n            (String) node.getProperties().get("name"),\n            (Integer) node.getProperties().get("age"),\n            (String) node.getProperties().get("gender"),\n            node.getVectorizableContent()\n        );\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-service-layer-pattern",children:"2. Service Layer Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Add business logic on top of ORM:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\n@Transactional  // CEF supports transactional indexing\npublic class MedicalKnowledgeService {\n    \n    @Autowired\n    private PatientKnowledgeRepository patientRepo;\n    \n    @Autowired\n    private KnowledgeIndexer indexer;\n    \n    /**\n     * Create patient with all related entities (like cascading persist)\n     */\n    public Mono<UUID> registerPatient(PatientRegistrationDTO dto) {\n        return Mono.defer(() -> {\n            // 1. Create patient node\n            NodeInput patientNode = new NodeInput(\n                null, "Patient",\n                Map.of("name", dto.getName(), "age", dto.getAge()),\n                dto.getMedicalHistory()\n            );\n            \n            return indexer.indexNode(patientNode)\n                .flatMap(patient -> {\n                    List<Mono<Edge>> edgeCreations = new ArrayList<>();\n                    \n                    // 2. Create edges to doctor\n                    if (dto.getDoctorId() != null) {\n                        EdgeInput treatsEdge = new EdgeInput(\n                            null, "TREATS",\n                            dto.getDoctorId(), patient.getId(),\n                            Map.of("since", LocalDate.now()),\n                            1.0\n                        );\n                        edgeCreations.add(indexer.indexEdge(treatsEdge));\n                    }\n                    \n                    // 3. Create edges to conditions\n                    for (UUID conditionId : dto.getConditionIds()) {\n                        EdgeInput hasCondition = new EdgeInput(\n                            null, "HAS_CONDITION",\n                            patient.getId(), conditionId,\n                            Map.of("diagnosedDate", LocalDate.now()),\n                            1.0\n                        );\n                        edgeCreations.add(indexer.indexEdge(hasCondition));\n                    }\n                    \n                    // 4. Wait for all edges\n                    return Flux.merge(edgeCreations)\n                        .then(Mono.just(patient.getId()));\n                });\n        });\n    }\n    \n    /**\n     * Get comprehensive patient context (like JPQL join fetch)\n     */\n    public Mono<PatientContextDTO> getPatientContext(UUID patientId) {\n        GraphQuery query = new GraphQuery(\n            "Get patient comprehensive context",\n            List.of(new ResolutionTarget(patientId.toString(), "Patient", 1)),\n            new TraversalHint(\n                List.of("HAS_CONDITION", "PRESCRIBED_MEDICATION", "TREATED_BY"),\n                2,  // 2-hop traversal\n                null\n            ),\n            null, null, null,\n            3, 20, true, 4000, 100, 100\n        );\n        \n        return retriever.retrieve(query)\n            .map(result -> {\n                ReasoningContext ctx = result.reasoningContext();\n                return new PatientContextDTO(\n                    ctx.rootNode(),\n                    extractConditions(ctx.relatedNodes()),\n                    extractMedications(ctx.relatedNodes()),\n                    extractDoctors(ctx.relatedNodes()),\n                    result.results()  // semantic chunks\n                );\n            });\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-lifecycle-hooks-like-jpa-callbacks",children:"3. Lifecycle Hooks (Like JPA Callbacks)"}),"\n",(0,r.jsx)(n.p,{children:"Implement entity lifecycle management:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class KnowledgeEntityListener {\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @PrePersist\n    public void beforeIndexNode(NodeInput input) {\n        log.info("Indexing node: {}", input.label());\n        validateNodeInput(input);\n    }\n    \n    @PostPersist\n    public void afterIndexNode(Node node) {\n        auditService.logNodeCreation(node);\n        notifySearchIndexUpdate(node);\n    }\n    \n    @PreUpdate\n    public void beforeUpdateNode(UUID nodeId, Map<String, Object> changes) {\n        auditService.logNodeUpdate(nodeId, changes);\n    }\n    \n    @PreRemove\n    public void beforeDeleteNode(UUID nodeId) {\n        // Check for dependent entities\n        long edgeCount = retriever.getNeighbors(nodeId, 1)\n            .count().block();\n        \n        if (edgeCount > 0) {\n            log.warn("Deleting node {} with {} relationships", nodeId, edgeCount);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"indexing-knowledge",children:"Indexing Knowledge"}),"\n",(0,r.jsx)(n.h3,{id:"batch-indexing-like-hibernates-statelesssession",children:"Batch Indexing (Like Hibernate's StatelessSession)"}),"\n",(0,r.jsx)(n.p,{children:"For initial loading or bulk operations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class KnowledgeBulkLoader {\n    \n    @Autowired\n    private KnowledgeIndexer indexer;\n    \n    /**\n     * Bulk load knowledge from data source\n     * Similar to Hibernate\'s batch insert\n     */\n    public Mono<IndexResult> bulkLoadPatients(List<PatientDTO> patients) {\n        // 1. Convert to node inputs\n        List<NodeInput> nodeInputs = patients.stream()\n            .map(this::toNodeInput)\n            .toList();\n        \n        // 2. Batch index (optimized with parallel embedding)\n        BatchInput batch = new BatchInput(nodeInputs, List.of(), List.of());\n        \n        return indexer.indexBatch(batch)\n            .doOnSuccess(result -> \n                log.info("Indexed {} patients in {}ms", \n                    result.nodesIndexed(), result.durationMs())\n            );\n    }\n    \n    /**\n     * Full index from data source (like Hibernate\'s schema export)\n     */\n    public Mono<IndexResult> fullIndexFromFiles(String dataDir) {\n        DataSource dataSource = new FileSystemDataSource(dataDir);\n        \n        return indexer.fullIndex(dataSource)\n            .doOnSuccess(result -> {\n                log.info("Full index complete:");\n                log.info("  Nodes: {}", result.nodesIndexed());\n                log.info("  Edges: {}", result.edgesIndexed());\n                log.info("  Chunks: {}", result.chunksIndexed());\n                log.info("  Duration: {}ms", result.durationMs());\n            });\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"incremental-updates-like-jpa-merge",children:"Incremental Updates (Like JPA Merge)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class PatientUpdateService {\n    \n    @Autowired\n    private KnowledgeIndexer indexer;\n    \n    /**\n     * Update patient information\n     * Similar to entityManager.merge(entity)\n     */\n    @Transactional\n    public Mono<Node> updatePatientMedicalHistory(\n        UUID patientId, \n        String newHistory\n    ) {\n        // 1. Get current node\n        return retriever.findNode(patientId)\n            .flatMap(currentNode -> {\n                // 2. Merge changes\n                Map<String, Object> updates = new HashMap<>(currentNode.getProperties());\n                updates.put("lastUpdate", LocalDateTime.now());\n                \n                // 3. Update with new vectorizable content\n                return indexer.updateNode(patientId, updates)\n                    .flatMap(updated -> {\n                        // 4. Re-index chunks if content changed\n                        if (!newHistory.equals(currentNode.getVectorizableContent())) {\n                            ChunkInput chunk = new ChunkInput(\n                                null, newHistory, patientId,\n                                Map.of("type", "medical_history")\n                            );\n                            return indexer.indexChunk(chunk)\n                                .thenReturn(updated);\n                        }\n                        return Mono.just(updated);\n                    });\n            });\n    }\n    \n    /**\n     * Add relationship (like adding to @ManyToMany collection)\n     */\n    public Mono<Edge> addConditionToPatient(UUID patientId, UUID conditionId) {\n        EdgeInput edge = new EdgeInput(\n            null, "HAS_CONDITION",\n            patientId, conditionId,\n            Map.of("diagnosedDate", LocalDate.now()),\n            1.0\n        );\n        \n        return indexer.indexEdge(edge);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"retrieving-context",children:"Retrieving Context"}),"\n",(0,r.jsx)(n.h3,{id:"basic-queries-like-jpql",children:"Basic Queries (Like JPQL)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class PatientQueryService {\n    \n    @Autowired\n    private KnowledgeRetriever retriever;\n    \n    // Find by ID (like em.find())\n    public Mono<Node> findById(UUID id) {\n        return retriever.findNode(id);\n    }\n    \n    // Find by label (like SELECT p FROM Patient p)\n    public Flux<Node> findAllPatients() {\n        return retriever.findNodesByLabel("Patient");\n    }\n    \n    // Find by property (like WHERE clause)\n    public Flux<Node> findPatientsByAge(int age) {\n        return retriever.findNodesByProperty("age", age);\n    }\n    \n    // Navigate relationships (like JOIN FETCH)\n    public Flux<Node> getPatientConditions(UUID patientId) {\n        return retriever.getChildren(patientId);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"complex-context-retrieval",children:"Complex Context Retrieval"}),"\n",(0,r.jsx)(n.p,{children:"The power of CEF ORM - assemble rich context automatically:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class ContextRetrievalService {\n    \n    @Autowired\n    private KnowledgeRetriever retriever;\n    \n    /**\n     * Entity-aware retrieval\n     * "Find John\'s treatment recommendations"\n     */\n    public Mono<SearchResult> getPatientTreatmentContext(String patientName) {\n        GraphQuery query = new GraphQuery(\n            "Find treatment recommendations for patient",\n            // Resolve entity by name\n            List.of(new ResolutionTarget(\n                patientName, \n                "Patient",  // type hint\n                1           // expect 1 match\n            )),\n            // Traverse relationships\n            new TraversalHint(\n                List.of("HAS_CONDITION", "PRESCRIBED_MEDICATION"),\n                2,  // 2-hop depth\n                Set.of(RelationSemantics.ATTRIBUTION, RelationSemantics.CAUSALITY)\n            ),\n            null, null, null,\n            3,    // minResults for fallback\n            10,   // topK chunks\n            true, // include reasoning context\n            4000, // token budget\n            100, 100\n        );\n        \n        return retriever.retrieve(query);\n    }\n    \n    /**\n     * Multi-hop reasoning\n     * "Find patients similar to John"\n     */\n    public Mono<SearchResult> findSimilarPatients(UUID patientId) {\n        // Strategy: \n        // 1. Get patient\'s conditions\n        // 2. Find other patients with same conditions (siblings in graph)\n        // 3. Rank by condition overlap\n        \n        return retriever.extractContext(\n            Set.of(patientId),\n            new GraphTraversal(\n                3,  // depth\n                List.of("HAS_CONDITION"),\n                null\n            )\n        ).flatMap(context -> {\n            // Use reasoning context to enhance query\n            Set<String> keywords = context.contextKeywords();\n            \n            GraphQuery query = new GraphQuery(\n                "Find patients with similar conditions: " + \n                    String.join(", ", keywords),\n                List.of(),  // no specific targets\n                new TraversalHint(\n                    List.of("HAS_CONDITION"),\n                    1,\n                    Set.of(RelationSemantics.ATTRIBUTION)\n                ),\n                null, null, null,\n                3, 10, true, 4000, 100, 100\n            );\n            \n            return retriever.retrieve(query);\n        });\n    }\n    \n    /**\n     * Graph pattern matching (advanced)\n     * Use new GraphPattern API for complex multi-hop queries\n     */\n    public Mono<SearchResult> findComorbidityPatterns() {\n        // Pattern: Patient \u2192 Condition \u2192 Patient \u2192 Medication\n        // (patients with conditions treated by same medications)\n        \n        GraphPattern pattern = new GraphPattern(\n            "comorbidity_pattern",\n            List.of(\n                new TraversalStep("Patient", "HAS_CONDITION", "Condition", 0),\n                new TraversalStep("Condition", "TREATED_WITH", "Medication", 1),\n                new TraversalStep("Medication", "PRESCRIBED_TO", "Patient", 2)\n            ),\n            List.of(\n                // Filter: only chronic conditions\n                Constraint.propertyEquals("Condition", "type", "chronic", 0)\n            ),\n            "Find comorbidity patterns via shared medications"\n        );\n        \n        GraphQuery query = new GraphQuery(\n            "Find comorbidity patterns",\n            List.of(),  // no entry point needed\n            null,\n            List.of(pattern),  // use pattern instead\n            null,\n            RankingStrategy.HYBRID,\n            3, 10, true, 4000, 100, 100\n        );\n        \n        return retriever.retrieve(query);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"automatic-fallback",children:"Automatic Fallback"}),"\n",(0,r.jsx)(n.p,{children:"CEF ORM intelligently falls back when graph traversal insufficient:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Scenario 1: Entity found, rich graph context\nGraphQuery query = new GraphQuery(\n    "John\'s diabetes treatment",\n    List.of(new ResolutionTarget("John", "Patient", 1)),\n    new TraversalHint(List.of("HAS_CONDITION", "PRESCRIBED_MEDICATION"), 2, null),\n    ...\n);\nSearchResult result = retriever.retrieve(query).block();\n// Strategy: HYBRID (graph traversal + vector search on related nodes)\n// Result: 12 chunks from John\'s medical graph\n\n// Scenario 2: Entity not found, fallback to semantic\nGraphQuery query = new GraphQuery(\n    "General diabetes treatment guidelines",\n    List.of(),  // no entity\n    null,\n    ...\n);\nSearchResult result = retriever.retrieve(query).block();\n// Strategy: VECTOR (pure semantic search)\n// Result: 8 chunks about diabetes treatment\n\n// Scenario 3: No semantic match, fallback to keyword\nGraphQuery query = new GraphQuery(\n    "XYZ-123 medication protocol",  // rare term\n    List.of(),\n    null,\n    ...\n);\nSearchResult result = retriever.retrieve(query).block();\n// Strategy: BM25 (keyword search)\n// Result: 3 chunks containing "XYZ-123"\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-caching-strategy-planned-for-v06",children:"1. Caching Strategy (Planned for v0.6)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Note: Distributed caching is currently on the roadmap. The following configuration demonstrates the planned API."})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class CacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager() {\n        CaffeineCacheManager manager = new CaffeineCacheManager(\n            "nodes", "search-results", "reasoning-contexts"\n        );\n        manager.setCaffeine(Caffeine.newBuilder()\n            .maximumSize(10_000)\n            .expireAfterWrite(Duration.ofMinutes(30))\n            .recordStats()\n        );\n        return manager;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-multi-tenancy-planned-for-v06",children:"2. Multi-Tenancy (Planned for v0.6)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Configuration\npublic class MultiTenantConfig {\n    \n    @Bean\n    public TenantKnowledgeIndexer tenantIndexer(KnowledgeIndexer baseIndexer) {\n        return new TenantKnowledgeIndexer(baseIndexer);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-validation-framework-like-bean-validation",children:"3. Validation Framework (Like Bean Validation)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Validated\npublic class ValidatedKnowledgeService {\n    \n    public Mono<Node> indexPatient(\n        @Valid @NotNull PatientNodeInput input\n    ) {\n        return indexer.indexNode(input.toNodeInput());\n    }\n}\n\n// Custom validator\npublic class PatientNodeInput {\n    \n    @NotBlank\n    private String name;\n    \n    @Min(0) @Max(150)\n    private int age;\n    \n    @Pattern(regexp = "M|F|O")\n    private String gender;\n    \n    @NotBlank\n    @Size(min = 50, message = "Medical history too short for meaningful context")\n    private String medicalHistory;\n    \n    public NodeInput toNodeInput() {\n        return new NodeInput(\n            null, "Patient",\n            Map.of("name", name, "age", age, "gender", gender),\n            medicalHistory\n        );\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-schema-evolution-like-flywayliquibase",children:"4. Schema Evolution (Like Flyway/Liquibase)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class KnowledgeSchemaEvolution {\n    \n    @Autowired\n    private KnowledgeIndexer indexer;\n    \n    @Autowired\n    private KnowledgeRetriever retriever;\n    \n    /**\n     * Version 1 \u2192 Version 2: Add ICD-10 codes to conditions\n     */\n    @PostConstruct\n    @Order(1)\n    public void migrateToV2() {\n        retriever.findNodesByLabel("Condition")\n            .flatMap(condition -> {\n                Map<String, Object> props = condition.getProperties();\n                \n                if (!props.containsKey("icd10Code")) {\n                    // Add missing field\n                    props.put("icd10Code", inferICD10Code(condition));\n                    return indexer.updateNode(condition.getId(), props);\n                }\n                \n                return Mono.just(condition);\n            })\n            .count()\n            .subscribe(count -> \n                log.info("Migrated {} conditions to v2", count)\n            );\n    }\n    \n    /**\n     * Version 2 \u2192 Version 3: Split Medication into Generic/Brand\n     */\n    @PostConstruct\n    @Order(2)\n    public void migrateToV3() {\n        // Similar pattern for schema evolution\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"production-deployment",children:"Production Deployment"}),"\n",(0,r.jsx)(n.h3,{id:"1-monitoring--observability",children:"1. Monitoring & Observability"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class ObservabilityConfig {\n    \n    @Bean\n    public MeterRegistry meterRegistry() {\n        return new SimpleMeterRegistry();\n    }\n}\n\n@Service\npublic class MonitoredRetrievalService {\n    \n    @Autowired\n    private KnowledgeRetriever retriever;\n    \n    @Autowired\n    private MeterRegistry registry;\n    \n    @Timed(value = "cef.retrieval.duration", description = "Knowledge retrieval duration")\n    public Mono<SearchResult> retrieve(GraphQuery query) {\n        return retriever.retrieve(query)\n            .doOnSuccess(result -> {\n                // Record strategy used\n                registry.counter("cef.retrieval.strategy", \n                    "strategy", result.strategy().name()).increment();\n                \n                // Record result count\n                registry.summary("cef.retrieval.results")\n                    .record(result.results().size());\n                \n                // Record graph traversal depth\n                if (result.reasoningContext() != null) {\n                    registry.summary("cef.graph.depth")\n                        .record(result.reasoningContext().depth());\n                }\n            });\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-health-checks",children:"2. Health Checks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class CefHealthIndicator implements HealthIndicator {\n    \n    @Autowired\n    private GraphStore graphStore;\n    \n    @Autowired\n    private VectorStore vectorStore;\n    \n    @Override\n    public Health health() {\n        try {\n            long nodeCount = graphStore.getNodeCount();\n            long edgeCount = graphStore.getEdgeCount();\n            long chunkCount = vectorStore.getChunkCount();\n            \n            return Health.up()\n                .withDetail("graph_store", graphStore.getImplementation())\n                .withDetail("vector_store", vectorStore.getImplementation())\n                .withDetail("node_count", nodeCount)\n                .withDetail("edge_count", edgeCount)\n                .withDetail("chunk_count", chunkCount)\n                .withDetail("avg_degree", edgeCount / (double) nodeCount)\n                .build();\n        } catch (Exception e) {\n            return Health.down()\n                .withException(e)\n                .build();\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-performance-tuning",children:"3. Performance Tuning"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"cef:\n  # Graph optimization\n  graph:\n    jgrapht:\n      max-nodes: 100000      # Increase if needed\n      preload-on-startup: true\n      cache-enabled: true\n  \n  # Vector optimization\n  vector:\n    postgres:\n      connection-pool-size: 20\n      batch-size: 500\n  \n  # Cache tuning\n  cache:\n    l1:\n      enabled: true\n      max-size: 10000\n      ttl-seconds: 1800\n    l2:\n      enabled: true\n      type: redis\n      redis:\n        host: redis-cluster\n        ttl-seconds: 3600\n  \n  # Search optimization\n  search:\n    default-top-k: 10\n    max-graph-depth: 3\n    enable-query-cache: true\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsx)(n.h4,{id:"issue-1-slow-retrieval",children:"Issue 1: Slow Retrieval"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Symptoms:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Retrieval taking >2 seconds"}),"\n",(0,r.jsx)(n.li,{children:"High CPU during graph traversal"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Diagnosis:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Autowired\nprivate MeterRegistry registry;\n\npublic void diagnoseSlowRetrieval() {\n    registry.find("cef.retrieval.duration").timers()\n        .forEach(timer -> {\n            log.info("Retrieval duration: mean={}ms, max={}ms",\n                timer.mean(TimeUnit.MILLISECONDS),\n                timer.max(TimeUnit.MILLISECONDS));\n        });\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Solutions:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduce traversal depth"}),": Change ",(0,r.jsx)(n.code,{children:"depth=3"})," to ",(0,r.jsx)(n.code,{children:"depth=2"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add caching"}),": Enable L2 cache for frequent queries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimize graph"}),": Switch from JGraphT to Neo4j for >100K nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limit result set"}),": Reduce ",(0,r.jsx)(n.code,{children:"topK"})," from 20 to 10"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"issue-2-out-of-memory-jgrapht",children:"Issue 2: Out of Memory (JGraphT)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Symptoms:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OutOfMemoryError"})," during graph loading"]}),"\n",(0,r.jsx)(n.li,{children:"Heap size constantly at 80%+"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Diagnosis:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"jcmd <pid> GC.heap_info\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Solutions:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Increase heap"}),": ",(0,r.jsx)(n.code,{children:"-Xmx4g"})," \u2192 ",(0,r.jsx)(n.code,{children:"-Xmx8g"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Switch to Neo4j"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"cef:\n  graph:\n    store: neo4j  # Disk-based, no memory limit\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy loading"}),": Disable preload"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"cef:\n  graph:\n    jgrapht:\n      preload-on-startup: false\n"})}),"\n",(0,r.jsx)(n.h4,{id:"issue-3-embedding-generation-slow",children:"Issue 3: Embedding Generation Slow"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Symptoms:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Indexing 1000 nodes takes >5 minutes"}),"\n",(0,r.jsx)(n.li,{children:"Embedding service timeout errors"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Solutions:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch embeddings"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"indexer.indexBatch(new BatchInput(\n    nodeInputs,\n    edgeInputs,\n    chunkInputs,\n    4  // parallelism\n));\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use faster provider"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"cef:\n  embedding:\n    provider: openai  # Faster than local Ollama\n    model: text-embedding-3-small\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"CEF provides an ORM abstraction for knowledge models just as Hibernate provides for transactional data:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nodes"})," \u2192 Entities (like ",(0,r.jsx)(n.code,{children:"@Entity"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edges"})," \u2192 Relationships (like ",(0,r.jsx)(n.code,{children:"@OneToMany"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RelationType"})," \u2192 Semantic mapping (like ",(0,r.jsx)(n.code,{children:"@JoinColumn"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"KnowledgeIndexer"})," \u2192 Persistence API (like ",(0,r.jsx)(n.code,{children:"EntityManager"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"KnowledgeRetriever"})," \u2192 Query API (like ",(0,r.jsx)(n.code,{children:"Repository"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best Practices:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Define knowledge models declaratively"}),"\n",(0,r.jsx)(n.li,{children:"Use repository pattern for domain facades"}),"\n",(0,r.jsx)(n.li,{children:"Leverage dual persistence (graph + vector)"}),"\n",(0,r.jsx)(n.li,{children:"Enable caching for frequently accessed contexts"}),"\n",(0,r.jsx)(n.li,{children:"Monitor performance metrics in production"}),"\n",(0,r.jsx)(n.li,{children:"Start with JGraphT, migrate to Neo4j when needed"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Next Steps:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Read ",(0,r.jsx)(n.a,{href:"/cef/docs/architecture",children:"Architecture"})," for deep dive"]}),"\n",(0,r.jsxs)(n.li,{children:["Review the ",(0,r.jsx)(n.a,{href:"/cef/docs/benchmarks",children:"Benchmarks"})," page for the published analyses"]}),"\n",(0,r.jsxs)(n.li,{children:["Explore test suite in ",(0,r.jsx)(n.code,{children:"cef-framework/src/test/java"})," for real-world examples"]}),"\n",(0,r.jsxs)(n.li,{children:["Visit ",(0,r.jsx)(n.a,{href:"https://ddse-foundation.github.io/",children:"DDSE Foundation"})," for updates and community resources"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Questions?"})," Open an issue or discussion on GitHub."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Want to contribute?"})," Contact DDSE Foundation at ",(0,r.jsx)(n.a,{href:"https://ddse-foundation.github.io/",children:"https://ddse-foundation.github.io/"})]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(6540);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);