"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[839],{5750:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"tutorials/build-your-first-model","title":"Hands-On: Build a Knowledge Model in 30 Minutes","description":"This tutorial walks through the same patterns exercised by the medical benchmark: defining relation semantics, indexing nodes/edges/chunks, and retrieving multi-hop context. Everything below is grounded in the beta-0.5 code and tests (no placeholders).","source":"@site/docs/tutorials/build-your-first-model.md","sourceDirName":"tutorials","slug":"/tutorials/build-your-first-model","permalink":"/cef/docs/tutorials/build-your-first-model","draft":false,"unlisted":false,"editUrl":"https://github.com/ddse-foundation/cef/tree/main/site/docs/tutorials/build-your-first-model.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"CEF User Guide: ORM for Context Engineering","permalink":"/cef/docs/user-guide"},"next":{"title":"Benchmarks (beta-0.5)","permalink":"/cef/docs/benchmarks"}}');var r=t(4848),a=t(8453);const s={},o="Hands-On: Build a Knowledge Model in 30 Minutes",d={},l=[{value:"1) Add the Framework",id:"1-add-the-framework",level:2},{value:"2) Configure a Tested Stack (DuckDB + Ollama)",id:"2-configure-a-tested-stack-duckdb--ollama",level:2},{value:"3) Declare Relation Semantics (Like JPA Mappings)",id:"3-declare-relation-semantics-like-jpa-mappings",level:2},{value:"4) Index Nodes, Edges, and Chunks (Dual Persistence)",id:"4-index-nodes-edges-and-chunks-dual-persistence",level:2},{value:"5) Retrieve Multi-Hop Context (Same Flow as Benchmarks)",id:"5-retrieve-multi-hop-context-same-flow-as-benchmarks",level:2},{value:"6) Validate with the Built-In Benchmarks",id:"6-validate-with-the-built-in-benchmarks",level:2},{value:"Where to Go Next",id:"where-to-go-next",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"hands-on-build-a-knowledge-model-in-30-minutes",children:"Hands-On: Build a Knowledge Model in 30 Minutes"})}),"\n",(0,r.jsx)(n.p,{children:"This tutorial walks through the same patterns exercised by the medical benchmark: defining relation semantics, indexing nodes/edges/chunks, and retrieving multi-hop context. Everything below is grounded in the beta-0.5 code and tests (no placeholders)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-add-the-framework",children:"1) Add the Framework"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>org.ddse.ml</groupId>\n    <artifactId>cef-framework</artifactId>\n    <version>beta-0.5</version>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-configure-a-tested-stack-duckdb--ollama",children:"2) Configure a Tested Stack (DuckDB + Ollama)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"src/main/resources/application.yml"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"cef:\n  graph:\n    store: jgrapht           # Tested to ~100K nodes in-memory\n  vector:\n    store: duckdb            # Embedded, no external DB\n  llm:\n    default-provider: ollama\n    ollama:\n      base-url: http://localhost:11434\n      model: nomic-embed-text\n\nspring:\n  main:\n    web-application-type: reactive\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Tested combo matches the benchmark harness: DuckDB + JGraphT + Ollama embeddings. vLLM (Qwen3-Coder-30B) was used for generation; you can plug it in later without changing code."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-declare-relation-semantics-like-jpa-mappings",children:"3) Declare Relation Semantics (Like JPA Mappings)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class KnowledgeModelConfig {\n\n    private final KnowledgeIndexer indexer;\n\n    public KnowledgeModelConfig(KnowledgeIndexer indexer) {\n        this.indexer = indexer;\n    }\n\n    @PostConstruct\n    public void initializeRelations() {\n        var relationTypes = List.of(\n            new RelationType("TREATS", RelationSemantics.CAUSAL, true,\n                "Doctor treats patient"),\n            new RelationType("HAS_CONDITION", RelationSemantics.ASSOCIATIVE, false,\n                "Patient has medical condition"),\n            new RelationType("PRESCRIBED_MEDICATION", RelationSemantics.CAUSAL, false,\n                "Patient prescribed medication")\n        );\n\n        indexer.initialize(relationTypes).block();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"These semantics mirror the benchmark scenarios (contraindications, comorbidities, shared doctors)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-index-nodes-edges-and-chunks-dual-persistence",children:"4) Index Nodes, Edges, and Chunks (Dual Persistence)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Entity nodes (graph + optional vectorizable content)\nNode patient = new Node(\n    null, "Patient",\n    Map.of("name", "John Doe", "age", 45, "gender", "M"),\n    "45-year-old male with type 2 diabetes and hypertension."\n);\nNode condition = new Node(\n    null, "Condition",\n    Map.of("name", "Type 2 Diabetes", "icd10", "E11.9"),\n    "**CONDITION PROFILE** Name: Type 2 Diabetes Mellitus..."\n);\nUUID patientId = indexer.indexNode(patient).block().getId();\nUUID conditionId = indexer.indexNode(condition).block().getId();\n\n// Typed relationship\nEdge hasCondition = new Edge(\n    null, "HAS_CONDITION", patientId, conditionId,\n    Map.of("diagnosedOn", "2025-01-10"), 1.0\n);\nindexer.indexEdge(hasCondition).block();\n\n// Additional chunks tied to the patient (semantic side)\nChunk encounter = new Chunk();\nencounter.setContent("**CLINICAL ENCOUNTER NOTE** Patient presents with chest pain...");\nencounter.setLinkedNodeId(patientId);\nencounter.setMetadata(Map.of("source", "ehr", "encounterId", "ENC-1001"));\nindexer.indexChunk(encounter).block();\n'})}),"\n",(0,r.jsx)(n.p,{children:"All writes update both the graph store and vector store automatically (dual persistence)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-retrieve-multi-hop-context-same-flow-as-benchmarks",children:"5) Retrieve Multi-Hop Context (Same Flow as Benchmarks)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public Mono<RetrievalResult> findPatientContext(String patientName) {\n    var graphQuery = new GraphQuery(\n        List.of(new ResolutionTarget(\n            patientName,          // semantic text used for entry-point resolution\n            "Patient",            // type hint\n            null                  // property filter\n        )),\n        new TraversalHint(\n            3,                    // max depth\n            List.of("HAS_CONDITION", "PRESCRIBED_MEDICATION"),\n            null                  // both directions\n        )\n    );\n\n    var request = RetrievalRequest.builder()\n        .query("Find context for " + patientName)\n        .graphQuery(graphQuery)\n        .topK(10)\n        .maxGraphNodes(50)\n        .maxTokenBudget(4000)\n        .build();\n\n    return retriever.retrieve(request);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"retriever"})," is the ",(0,r.jsx)(n.code,{children:"org.ddse.ml.cef.api.KnowledgeRetriever"})," bean provided by Spring."]}),"\n",(0,r.jsx)(n.p,{children:"Retrieval order (matches the benchmark harness):"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Resolve candidate Patient nodes via semantic search (with the type hint)."}),"\n",(0,r.jsxs)(n.li,{children:["Traverse ",(0,r.jsx)(n.code,{children:"HAS_CONDITION"})," and ",(0,r.jsx)(n.code,{children:"PRESCRIBED_MEDICATION"})," up to depth 3."]}),"\n",(0,r.jsx)(n.li,{children:"Run vector search constrained to the traversed subgraph."}),"\n",(0,r.jsx)(n.li,{children:"Fallback to vector-only if fewer than 3 results remain."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This is the same flow that delivered 12 vs 5 chunks for contraindication discovery."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-validate-with-the-built-in-benchmarks",children:"6) Validate with the Built-In Benchmarks"}),"\n",(0,r.jsx)(n.p,{children:"Run the same suite that produced the published numbers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd cef-framework\nmvn -Dtest=MedicalBenchmarkTest test\n# Reports: cef-framework/BENCHMARK_REPORT.md, BENCHMARK_REPORT_2.md\n"})}),"\n",(0,r.jsx)(n.p,{children:"Key expected outputs:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Scenario 1 (contraindications): ",(0,r.jsx)(n.strong,{children:"12 vs 5"})," chunks (+140%)."]}),"\n",(0,r.jsxs)(n.li,{children:["Scenario 4 (shared doctors): ",(0,r.jsx)(n.strong,{children:"16 vs 5"})," chunks (+220%)."]}),"\n",(0,r.jsxs)(n.li,{children:["Advanced separation/aggregation (Benchmark 2): ",(0,r.jsx)(n.strong,{children:"+6 to +9 chunks"})," over vector-only."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"where-to-go-next",children:"Where to Go Next"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Swap storage backends (PostgreSQL/pgvector, Neo4j) in ",(0,r.jsx)(n.code,{children:"application.yml"})," once you need larger graphs."]}),"\n",(0,r.jsx)(n.li,{children:"Expose the MCP tool to your LLM so it receives the schema and required fields automatically."}),"\n",(0,r.jsx)(n.li,{children:"Add more relation types (TEMPORAL, HIERARCHY) to reflect your domain and guide traversal."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);