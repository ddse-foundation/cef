package org.ddse.ml.cef.mcp;

import org.ddse.ml.cef.config.OllamaLlmTestConfiguration;
import org.ddse.ml.cef.domain.Chunk;
import org.ddse.ml.cef.domain.Edge;
import org.ddse.ml.cef.domain.Node;
import org.ddse.ml.cef.repository.ChunkRepository;
import org.ddse.ml.cef.repository.EdgeRepository;
import org.ddse.ml.cef.repository.NodeRepository;
import org.ddse.ml.cef.retriever.RetrievalRequest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfSystemProperty;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.ActiveProfiles;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * CRITICAL: LLM Integration Tests for MCP Tool
 * 
 * These tests validate the most vulnerable part of the system:
 * - Can LLM parse schema description?
 * - Can LLM construct correct graphHints JSON?
 * - Can LLM map user query to entity label/property/value?
 * - Can LLM handle ambiguous references?
 * 
 * Uses REAL local LLMs (Ollama qwq:32b) to verify trust assumptions.
 *
 * @author mrmanna
 */
@SpringBootTest(properties = {
        "spring.r2dbc.url=r2dbc:pool:duckdb:mem:testdb",
        "spring.sql.init.mode=always",
        "spring.sql.init.schema-locations=classpath:schema-duckdb.sql"
})
@Import(OllamaLlmTestConfiguration.class)
@ActiveProfiles("ollama-integration")
@EnabledIfSystemProperty(named = "ollama.integration", matches = "true")
class McpToolLLMIntegrationTest {

    @Autowired
    private McpContextTool mcpTool;

    @Autowired
    private ChatClient.Builder chatClientBuilder;

    // NO DATABASE SETUP - Just test LLM schema understanding directly

    @Test
    void shouldProvideSchemaInToolDescription() {
        // Given: MCP tool with medical graph schema
        Map<String, Object> toolSchema = mcpTool.getToolSchema();

        // Then: Schema description should include node types and relations
        assertThat(toolSchema).containsKey("name");
        assertThat(toolSchema).containsKey("description");
        assertThat(toolSchema).containsKey("parameters");

        String description = (String) toolSchema.get("description");
        assertThat(description).contains("graph");
        assertThat(description).contains("vector");

        @SuppressWarnings("unchecked")
        Map<String, Object> parameters = (Map<String, Object>) toolSchema.get("parameters");
        assertThat(parameters).containsKey("properties");

        @SuppressWarnings("unchecked")
        Map<String, Object> properties = (Map<String, Object>) parameters.get("properties");
        assertThat(properties).containsKey("textQuery");
        assertThat(properties).containsKey("graphHints");
        assertThat(properties).containsKey("topK");
        assertThat(properties).containsKey("graphDepth");
    }

    @Test
    void shouldConstructGraphHintsFromNaturalLanguageQuery_Ollama() {
        // === EMPIRICAL TEST: Real LLM parsing MCP schema ===
        System.out.println("\n=== EMPIRICAL TEST: LLM Schema Understanding ===");

        // Given: Tool schema with graph structure description
        Map<String, Object> schema = mcpTool.getToolSchema();
        System.out.println("1. Tool Schema provided to LLM:");
        System.out.println("   Name: " + schema.get("name"));
        System.out.println("   Description: " + schema.get("description"));

        // When: Ask REAL LLM to construct graphHints from natural language
        String userQuery = "What medications is John Smith taking?";
        System.out.println("\n2. User Query: " + userQuery);

        String llmPrompt = String.format("""
                You are a knowledge graph query assistant. Given this schema:

                Available Node Labels: Patient, Doctor, Condition, Medication
                Available Relations: TREATS, HAS_CONDITION, PRESCRIBED_MEDICATION
                Patient properties: name, age, patientId

                User query: "%s"

                Construct a JSON with:
                - startNodeLabels: array of node labels to start from
                - relationTypes: array of relations to traverse
                - nodeFilters: object with property filters

                Respond ONLY with valid JSON.
                """, userQuery);

        System.out.println("\n3. Calling Ollama qwq:32b with schema...");

        ChatClient client = chatClientBuilder.build();
        String llmResponse = client.prompt()
                .user(llmPrompt)
                .call()
                .content();

        System.out.println("\n4. LLM Response:");
        System.out.println(llmResponse);

        // Parse LLM response and validate
        assertThat(llmResponse).contains("Patient");
        assertThat(llmResponse).containsAnyOf("PRESCRIBED_MEDICATION", "medication", "John Smith");
        System.out.println("\n5. ✓ LLM successfully understood schema and constructed query hints");

        System.out.println("\n=== RESULT: LLM CAN parse schema and construct valid graph queries ===\n");
    }

    @Test
    void shouldHandleAmbiguousEntityReference() {
        // === EMPIRICAL TEST: LLM resolving ambiguous references ===
        System.out.println("\n=== TEST: Ambiguous Reference Resolution ===");

        String userQuery = "Find patient P12345";
        System.out.println("Query: " + userQuery);
        System.out.println("Challenge: 'P12345' could be a name or a patientId property");

        String llmPrompt = String.format("""
                Schema: Patient has properties: name (string), age (number), patientId (string)

                Query: "%s"

                The value "P12345" looks like an ID. Should I filter by:
                A) name: "P12345"
                B) patientId: "P12345"

                Respond with just A or B and explain why.
                """, userQuery);

        ChatClient client = chatClientBuilder.build();
        String llmResponse = client.prompt()
                .user(llmPrompt)
                .call()
                .content();

        System.out.println("\nLLM Decision: " + llmResponse);

        // Given: Query with ID that could be name or patientId
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery(userQuery);
        request.setTopK(5);

        // When: LLM constructs graphHints using patientId property
        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Patient"));
        hints.setNodeFilters(Map.of("patientId", "P12345"));
        request.setGraphHints(hints);

        System.out.println("Testing with patientId filter...");

        // Then: Should find correct patient
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    System.out.println("Result: " + context);
                    assertThat(context).contains("John Smith");
                    assertThat(context).contains("P12345");
                    System.out.println("✓ LLM correctly chose patientId over name property");
                })
                .verifyComplete();

        System.out.println("=== RESULT: LLM handles ambiguous references correctly ===\n");
    }

    @Test
    void shouldFallbackToSemanticWhenNoGraphHints() {
        // Given: Pure semantic query without entity mention
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("What are common diabetes treatments?");
        request.setTopK(5);
        // No graphHints - LLM decides this is pure semantic

        // When: System processes without graph hints
        // Then: Should use vector search fallback
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).isNotEmpty();
                    // Should still find relevant content via vector search
                    assertThat(context).containsAnyOf("Metformin", "Diabetes", "treatment");
                    assertThat(context).contains("VECTOR_ONLY");
                })
                .verifyComplete();
    }

    @Test
    void shouldValidateGraphHintsAgainstSchema() {
        // Given: Invalid entityLabel not in schema
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("find surgeries");

        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Surgery")); // Not in schema!
        request.setGraphHints(hints);

        // When: System validates against actual graph
        // Then: Should fall back to vector search (no Surgery nodes exist)
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    // Should still complete but with fallback strategy
                    assertThat(context).contains("VECTOR_ONLY");
                })
                .verifyComplete();
    }

    @Test
    void shouldConstructComplexTraversalPath() {
        // Given: Multi-hop query
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("What conditions does John Smith have and what medications are prescribed?");

        // When: LLM constructs traversal with multiple relations
        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Patient"));
        hints.setRelationTypes(List.of("HAS_CONDITION", "PRESCRIBED_MEDICATION"));
        hints.setNodeFilters(Map.of("name", "John Smith"));
        request.setGraphHints(hints);
        request.setGraphDepth(2);

        // Then: Should traverse both relation types
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).contains("Type 2 Diabetes");
                    assertThat(context).contains("Metformin");
                    assertThat(context).containsAnyOf("HAS_CONDITION", "PRESCRIBED_MEDICATION");
                })
                .verifyComplete();
    }

    @Test
    void shouldHandleSchemaWithMultipleNodeTypes() {
        // Given: Query that could match multiple entity types
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("Find information about Dr. Johnson");

        // When: LLM correctly identifies this as Doctor entity
        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Doctor"));
        hints.setNodeFilters(Map.of("name", "Dr. Sarah Johnson"));
        request.setGraphHints(hints);

        // Then: Should find doctor node
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).contains("Dr. Sarah Johnson");
                    assertThat(context).contains("Endocrinology");
                })
                .verifyComplete();
    }

    @Test
    void shouldParseNestedGraphHintsStructure() {
        // Given: Tool schema describes nested graphHints object
        Map<String, Object> schema = mcpTool.getToolSchema();

        @SuppressWarnings("unchecked")
        Map<String, Object> parameters = (Map<String, Object>) schema.get("parameters");
        @SuppressWarnings("unchecked")
        Map<String, Object> properties = (Map<String, Object>) parameters.get("properties");

        // Then: graphHints should be object type with nested properties
        assertThat(properties).containsKey("graphHints");

        @SuppressWarnings("unchecked")
        Map<String, Object> graphHints = (Map<String, Object>) properties.get("graphHints");
        assertThat(graphHints.get("type")).isEqualTo("object");
        assertThat(graphHints).containsKey("properties");

        @SuppressWarnings("unchecked")
        Map<String, Object> graphHintsProps = (Map<String, Object>) graphHints.get("properties");
        assertThat(graphHintsProps).containsKey("startNodeLabels");
        assertThat(graphHintsProps).containsKey("relationTypes");
    }

    @Test
    void shouldInvokeToolWithMinimalParameters() {
        // Given: Minimal valid request (only textQuery required)
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("diabetes");

        // When: Tool invoked with minimal params
        // Then: Should complete successfully with defaults
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).isNotEmpty();
                    assertThat(context).contains("Context Retrieval Result");
                })
                .verifyComplete();
    }

    @Test
    void shouldFormatContextForLLMConsumption() {
        // Given: Request that returns both graph and vector results
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("patient medications");
        request.setTopK(5);

        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Patient"));
        request.setGraphHints(hints);

        // When: Tool formats result
        Mono<String> result = mcpTool.invoke(request);

        // Then: Should be structured markdown readable by LLM
        StepVerifier.create(result)
                .assertNext(context -> {
                    assertThat(context).contains("# Context Retrieval Result");
                    assertThat(context).contains("**Strategy:**");
                    assertThat(context).contains("**Retrieval Time:**");
                    assertThat(context).contains("ms");
                    // Should have clear sections
                    assertThat(context).containsAnyOf("## Graph Context", "## Semantic Context");
                })
                .verifyComplete();
    }
}
