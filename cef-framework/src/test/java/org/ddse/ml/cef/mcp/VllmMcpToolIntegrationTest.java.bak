package org.ddse.ml.cef.mcp;

import org.ddse.ml.cef.base.BaseLLMIntegrationTest;
import org.ddse.ml.cef.config.VllmTestConfiguration;
import org.ddse.ml.cef.fixtures.MedicalDomainFixtures;
import org.ddse.ml.cef.retriever.RetrievalRequest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfSystemProperty;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.ActiveProfiles;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Professional integration tests for MCP Tool with real LLM (vLLM Qwen3-Coder-30B).
 * 
 * <p>
 * <b>Purpose:</b> Validate LLM can parse MCP tool schema and construct valid graph queries
 * from natural language. This is CRITICAL for trusting LLM-driven retrieval.
 * 
 * <p>
 * <b>Test Organization:</b>
 * <ul>
 * <li>Schema Understanding: LLM parses tool schema correctly</li>
 * <li>GraphHints Construction: LLM builds valid graph queries from natural language</li>
 * <li>End-to-End Retrieval: Full MCP tool invocation with real data</li>
 * <li>Fallback Mechanisms: Semantic search when graph queries fail</li>
 * </ul>
 * 
 * <p>
 * <b>Prerequisites:</b>
 * <ul>
 * <li>vLLM running: localhost:8001 with Qwen3-Coder-30B</li>
 * <li>Ollama: nomic-embed-text:latest for embeddings</li>
 * <li>Run with: mvn test -Dvllm.integration=true -Dtest=VllmMcpToolIntegrationTest</li>
 * </ul>
 * 
 * <p>
 * <b>Success Criteria:</b>
 * <ol>
 * <li>LLM correctly parses MCP schema (node types, relations, properties)</li>
 * <li>LLM constructs valid graphHints JSON from natural language</li>
 * <li>Graph traversal returns expected nodes/edges for 2-3 hop queries</li>
 * <li>Semantic fallback triggers when graph query yields 0 results</li>
 * <li>Hybrid strategy combines graph + semantic for comprehensive context</li>
 * </ol>
 * 
 * @author mrmanna
 */
@Import(VllmTestConfiguration.class)
@ActiveProfiles("vllm-integration")
@EnabledIfSystemProperty(named = "vllm.integration", matches = "true")
@DisplayName("MCP Tool LLM Integration Tests (vLLM Qwen3-Coder-30B)")
class VllmMcpToolIntegrationTest extends BaseLLMIntegrationTest {

    @Autowired
    private McpContextTool mcpTool;

    private MedicalDomainFixtures.MedicalScenario medicalScenario;

    /**
     * Setup: Load medical domain test data before each test.
     * Creates Patient, Doctor, Conditions, Medications with real embeddings.
     */
    @BeforeEach
    void setupMedicalScenario() {
        logger.info("Setting up medical domain scenario with vLLM + Ollama embeddings...");

        medicalScenario = medicalFixtures.createDiabetesScenario(embeddingModel);

        saveNodes(medicalScenario.nodes());
        saveEdges(medicalScenario.edges());
        saveChunks(medicalScenario.chunks());

        logger.info("Medical scenario loaded: {} nodes, {} edges, {} chunks",
                medicalScenario.nodes().size(),
                medicalScenario.edges().size(),
                medicalScenario.chunks().size());
    }

    // ========================================
    // Schema Understanding Tests
    // ========================================

    @Nested
    @DisplayName("Schema Understanding Tests")
    class SchemaUnderstandingTests {

        @Test
        @DisplayName("Tool schema should provide complete node and relation types")
        void shouldProvideCompleteSchemaInformation() {
        // Given: vLLM with Qwen3-Coder-30B (strong tool calling)
        Map<String, Object> toolSchema = mcpTool.getToolSchema();

        // When: ChatClient configured with tool
        ChatClient chatClient = chatClientBuilder.build();

        // Then: Tool schema should be properly formatted for OpenAI-compatible API
        assertThat(toolSchema).containsKey("name");
        assertThat(toolSchema.get("name")).isEqualTo("retrieve_context");
        assertThat(toolSchema).containsKey("parameters");

        // vLLM should be able to parse this schema format
        @SuppressWarnings("unchecked")
        Map<String, Object> parameters = (Map<String, Object>) toolSchema.get("parameters");
        assertThat(parameters.get("type")).isEqualTo("object");
    }

    @Test
    void shouldConstructGraphHintsForLegalQuery_Vllm() {
        // Given: Legal domain query with entity reference
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("What are TechCo Inc's payment obligations?");

        // When: vLLM constructs graphHints (simulated)
        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Party"));
        hints.setRelationTypes(List.of("PARTY_TO", "HAS_CLAUSE", "HAS_OBLIGATION"));
        hints.setNodeFilters(Map.of("name", "TechCo Inc"));
        request.setGraphHints(hints);
        request.setGraphDepth(3); // Need depth 3: Party -> Contract -> Clause -> Obligation

        // Then: Should traverse to obligations
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).contains("TechCo");
                    assertThat(context).contains("$100,000");
                    assertThat(context).containsAnyOf("Payment", "obligation");
                })
                .verifyComplete();
    }

    @Test
    void shouldHandleComplexMultiEntityQuery() {
        // Given: Query mentioning multiple entities
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("Show the contract between Acme Corporation and Beta Inc");

        // When: vLLM identifies this as Contract query with party filters
        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Contract"));
        hints.setRelationTypes(List.of("HAS_PARTY"));
        request.setGraphHints(hints);
        request.setGraphDepth(2);

        // Then: Should find contract linking both parties
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).contains("Acme Corporation");
                    assertThat(context).contains("Beta Inc");
                    assertThat(context).contains("Software License Agreement");
                })
                .verifyComplete();
    }

    @Test
    void shouldHandleSchemaEvolutionAtRuntime() {
        // Given: Schema with existing entities
        Map<String, Object> initialSchema = mcpTool.getToolSchema();

        // When: New node type added (simulate by adding to graph)
        Node amendment = new Node();
        amendment.setId(UUID.randomUUID());
        amendment.setLabel("Amendment");
        amendment.setProperties(Map.of("amendmentId", "A-001"));
        nodeRepository.save(amendment).block();

        // Then: Tool schema should still be accessible
        // (In production, schema registry would refresh)
        Map<String, Object> currentSchema = mcpTool.getToolSchema();
        assertThat(currentSchema).isNotNull();
        assertThat(currentSchema).containsKey("name");
    }

    @Test
    void shouldGenerateWellFormedJSONStructure_Vllm() {
        // Given: Complex request structure
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("contract clauses");

        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Contract"));
        hints.setRelationTypes(List.of("HAS_CLAUSE"));
        hints.setNodeFilters(Map.of("contractId", "C-2024-001"));
        request.setGraphHints(hints);
        request.setTopK(10);
        request.setGraphDepth(2);

        // When: Request is processed
        // Then: System should handle nested JSON structure
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).isNotEmpty();
                    assertThat(context).contains("Clause");
                })
                .verifyComplete();
    }

    @Test
    void shouldHandleDeepGraphTraversal() {
        // Given: Query requiring 3-hop traversal
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("obligations in Acme contracts");

        // When: Deep traversal: Party -> Contract -> Clause -> Obligation
        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Party"));
        hints.setRelationTypes(List.of("HAS_PARTY", "HAS_CLAUSE", "CREATES_OBLIGATION"));
        hints.setNodeFilters(Map.of("name", "Acme Corporation", "role", "Licensor"));
        request.setGraphHints(hints);
        request.setGraphDepth(3);

        // Then: Should reach obligation nodes
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).contains("Acme");
                    assertThat(context).containsAnyOf("obligation", "Payment", "$10,000");
                })
                .verifyComplete();
    }

    @Test
    void shouldCombineGraphAndSemanticResults() {
        // Given: Query that benefits from hybrid approach
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("payment terms for Beta Inc");

        // When: Graph hints for entity + semantic keywords
        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Party"));
        hints.setNodeFilters(Map.of("name", "Beta Inc"));
        request.setGraphHints(hints);
        request.setSemanticKeywords(List.of("payment", "terms", "obligation"));
        request.setTopK(5);

        // Then: Should use hybrid strategy
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    assertThat(context).contains("Beta Inc");
                    assertThat(context).contains("payment");
                    // Should indicate hybrid or graph strategy
                    assertThat(context).containsAnyOf("HYBRID", "GRAPH");
                })
                .verifyComplete();
    }

    @Test
    void shouldFormatComplexResultsForVllm() {
        // Given: Query returning graph structure
        RetrievalRequest request = new RetrievalRequest();
        request.setTextQuery("contract structure");

        RetrievalRequest.GraphHints hints = new RetrievalRequest.GraphHints();
        hints.setStartNodeLabels(List.of("Contract"));
        request.setGraphHints(hints);
        request.setGraphDepth(2);

        // When: Result formatted for LLM
        StepVerifier.create(mcpTool.invoke(request))
                .assertNext(context -> {
                    // Should have clear markdown structure
                    assertThat(context).contains("# Context Retrieval Result");
                    assertThat(context).contains("**Strategy:**");

                    // Should show nodes and relationships
                    if (context.contains("## Graph Context")) {
                        assertThat(context).contains("### Nodes");
                        assertThat(context).containsAnyOf("Contract", "Party", "Clause");
                    }

                    // vLLM should be able to parse this structured output
                    assertThat(context).matches(".*\\*\\*.*\\*\\*.*"); // Contains bold markdown
                })
                .verifyComplete();
    }
}
