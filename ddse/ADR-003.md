# ADR-003: Medical Domain Example Implementation

**Status:** Accepted  
**Date:** 2024-11-24  
**Authors:** CEF Project Team  
**Depends On:** ADR-002 (Framework Architecture)

---

## Context

This ADR describes the medical domain example that demonstrates CEF framework capabilities. The example shows how to:
1. Define domain entities using framework abstractions
2. Create custom parsers for domain-specific data formats
3. Implement lifecycle hooks and validation
4. Build a React UI with real-time chat and graph visualization
5. Switch between databases and LLM providers live

---

## Decision

Build a **Medical Knowledge Assistant** that indexes medical knowledge (patients, doctors, conditions, medications, documents) and provides AI-powered chat with graph-based reasoning.

---

## Medical Domain Model

### Domain Entities (User Defines)

```java
// User creates domain POJOs - framework doesn't know these
public class PatientDTO {
    private UUID id;
    private String name;
    private int age;
    private String gender;
    private String medicalRecordNumber;
    private String symptoms;
    private String medicalHistory;
    private List<String> allergies;
}

public class DoctorDTO {
    private UUID id;
    private String name;
    private String specialization;  // cardiology, neurology, etc.
    private String licenseNumber;
    private String bio;
}

public class ConditionDTO {
    private UUID id;
    private String name;
    private String icd10Code;
    private String description;
    private List<String> symptoms;
}

public class MedicationDTO {
    private UUID id;
    private String name;
    private String type;  // tablet, injection, etc.
    private String description;
    private List<String> sideEffects;
}
```

### Relation Types - Domain-Specific Extensions

**Note:** Framework provides mandatory relationships: `IS_A`, `CONTAINS`, `CHILD_OF`

```java
@Configuration
public class MedicalDomainConfig {
    
    @Bean
    public List<RelationType> medicalRelationTypes() {
        return List.of(
            // Framework mandatory (already provided by CEF)
            // - IS_A (hierarchy)
            // - CONTAINS (composition)
            // - CHILD_OF (parent-child)
            
            // Domain-specific medical relationships
            new RelationType("HAS_CONDITION", RelationSemantics.ASSOCIATION, false,
                "Patient has a medical condition"),
            new RelationType("TREATS", RelationSemantics.ASSOCIATION, true,
                "Doctor treats patient (bidirectional)"),
            new RelationType("PRESCRIBED_FOR", RelationSemantics.ASSOCIATION, false,
                "Medication prescribed for condition"),
            new RelationType("HAS_SYMPTOM", RelationSemantics.ASSOCIATION, false,
                "Condition has symptom"),
            new RelationType("PART_OF_BODY", RelationSemantics.HIERARCHY, false,
                "Body part hierarchy (e.g., Heart PART_OF_BODY Cardiovascular System)"),
            new RelationType("FOLLOWED_BY", RelationSemantics.SEQUENCE, false,
                "Treatment step followed by another"),
            new RelationType("REFERS_TO", RelationSemantics.REFERENCE, false,
                "Document refers to entity")
        );
    }
    
    @Bean
    public List<NodeInput> rootNodes() {
        // User MUST provide at least one parent node
        return List.of(
            new NodeInput(
                UUID.randomUUID(),
                "MedicalEntity",
                Map.of("description", "Root of medical ontology", "type", "root"),
                null
            ),
            new NodeInput(
                UUID.randomUUID(),
                "ClinicalProcess",
                Map.of("description", "Root of clinical processes", "type", "root"),
                null
            )
        );
    }
}
```

---

## Custom Domain Parser with PDF Support

### Medical PDF Prescription Parser (Extends AbstractParser)

The example demonstrates parsing **real-world PDF prescriptions** to extract structured medical data for natural language queries.

#### Architecture: PDF Reader → ANTLR Parser

```java
@Component
public class MedicalPdfParser extends AbstractParser<MedicalParsedData> {
    
    private final PdfReaderService pdfReader;  // Framework provides
    private final ParserFactory parserFactory;
    
    public MedicalPdfParser(PdfReaderService pdfReader, ParserFactory parserFactory) {
        this.pdfReader = pdfReader;
        this.parserFactory = parserFactory;
    }
    
    @Override
    public List<String> getSupportedExtensions() {
        return List.of(".pdf");
    }
    
    @Override
    public int getOrder() {
        return 10;  // Higher priority than framework's default PdfParser (100)
    }
    
    @Override
    public MedicalParsedData parse(InputStream input, ParseContext context) 
        throws ParseException {
        try {
            // Step 1: Extract text from PDF using framework's PdfReaderService
            String pdfText = pdfReader.extractText(input);
            
            // Step 2: Use ANTLR4 grammar to parse prescription format
            CharStream charStream = CharStreams.fromString(pdfText);
            PrescriptionLexer lexer = new PrescriptionLexer(charStream);
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            PrescriptionParser parser = new PrescriptionParser(tokens);
            
            // Step 3: Parse with custom ANTLR grammar for prescription format
            PrescriptionParser.DocumentContext tree = parser.document();
            
            // Step 4: Use visitor to extract structured data
            PrescriptionVisitor visitor = new PrescriptionVisitor(context);
            MedicalParsedData parsed = visitor.visit(tree);
            
            return parsed;
        } catch (Exception e) {
            throw new ParseException("Failed to parse prescription PDF: " + 
                context.sourcePath(), e);
        }
    }
    
    @Override
    public List<NodeInput> extractNodes(MedicalParsedData data) {
        List<NodeInput> nodes = new ArrayList<>();
        
        // Extract patient from prescription header
        PatientDTO patient = data.getPatient();
        nodes.add(new NodeInput(
            patient.getId(),
            "Patient",
            Map.of(
                "name", patient.getName(),
                "age", patient.getAge(),
                "gender", patient.getGender(),
                "mrn", patient.getMedicalRecordNumber(),
                "allergies", patient.getAllergies()
            ),
            // Vectorizable content for NLP queries
            String.format("Patient: %s, Age: %d, Gender: %s, Allergies: %s",
                patient.getName(), patient.getAge(), patient.getGender(),
                String.join(", ", patient.getAllergies()))
        ));
        
        // Extract prescribing doctor
        DoctorDTO doctor = data.getDoctor();
        nodes.add(new NodeInput(
            doctor.getId(),
            "Doctor",
            Map.of(
                "name", doctor.getName(),
                "specialization", doctor.getSpecialization(),
                "license", doctor.getLicenseNumber()
            ),
            String.format("Dr. %s, Specialization: %s, License: %s",
                doctor.getName(), doctor.getSpecialization(), doctor.getLicenseNumber())
        ));
        
        // Extract diagnosis/conditions mentioned in prescription
        for (ConditionDTO condition : data.getConditions()) {
            nodes.add(new NodeInput(
                condition.getId(),
                "Condition",
                Map.of(
                    "name", condition.getName(),
                    "icd10", condition.getIcd10Code()
                ),
                String.format("Condition: %s (ICD-10: %s), Symptoms: %s",
                    condition.getName(), condition.getIcd10Code(),
                    String.join(", ", condition.getSymptoms()))
            ));
        }
        
        // Extract prescribed medications
        for (MedicationDTO med : data.getMedications()) {
            nodes.add(new NodeInput(
                med.getId(),
                "Medication",
                Map.of(
                    "name", med.getName(),
                    "type", med.getType(),
                    "dosage", med.getDosage(),
                    "frequency", med.getFrequency(),
                    "duration", med.getDuration()
                ),
                String.format("Medication: %s, Dosage: %s, Frequency: %s, Duration: %s",
                    med.getName(), med.getDosage(), med.getFrequency(), med.getDuration())
            ));
        }
        
        return nodes;
    }
    
    @Override
    public List<EdgeInput> extractEdges(MedicalParsedData data) {
        List<EdgeInput> edges = new ArrayList<>();
        
        // Extract patient-condition relationships
        for (PatientCondition pc : data.getPatientConditions()) {
            edges.add(new EdgeInput(
                null,  // Auto-generate ID
                "HAS_CONDITION",
                pc.getPatientId(),
                pc.getConditionId(),
                Map.of(
                    "diagnosedDate", pc.getDiagnosedDate(),
                    "severity", pc.getSeverity(),
                    "status", pc.getStatus()
                ),
                null  // No weight
            ));
        }
        
        // Extract doctor-patient relationships
        for (DoctorPatient dp : data.getDoctorPatients()) {
            edges.add(new EdgeInput(
                null,
                "TREATS",
                dp.getDoctorId(),
                dp.getPatientId(),
                Map.of(
                    "since", dp.getSince(),
                    "isPrimary", dp.isPrimary()
                ),
                null
            ));
        }
        
        // Extract medication-condition relationships
        for (MedicationCondition mc : data.getMedicationConditions()) {
            edges.add(new EdgeInput(
                null,
                "PRESCRIBED_MEDICATION",
                mc.getConditionId(),
                mc.getMedicationId(),
                Map.of(
                    "dosage", mc.getDosage(),
                    "frequency", mc.getFrequency()
                ),
                null
            ));
        }
        
        return edges;
    }
    
    @Override
    public List<ChunkInput> extractChunks(MedicalParsedData data) {
        List<ChunkInput> chunks = new ArrayList<>();
        
        // Extract documents
        for (DocumentInfo doc : data.getDocuments()) {
            // Document content will be chunked automatically by framework
            chunks.add(new ChunkInput(
                null,
                doc.getContent(),
                null,  // Not linked to specific node
                Map.of(
                    "title", doc.getTitle(),
                    "type", doc.getType(),
                    "source", doc.getSource(),
                    "year", doc.getYear(),
                    "topic", doc.getTopic()
                )
            ));
        }
        
        return chunks;
    }
}
```

---

## In-Memory Graph with JGraphT

### MedicalGraphManager

```java
@Component
public class MedicalGraphManager {
    
    private final Graph<Node, Edge> inMemoryGraph; // JGraphT DirectedGraph
    private final NodeRepository nodeRepository;
    private final EdgeRepository edgeRepository;
    
    public MedicalGraphManager(NodeRepository nodeRepository, EdgeRepository edgeRepository) {
        this.nodeRepository = nodeRepository;
        this.edgeRepository = edgeRepository;
        this.inMemoryGraph = new DirectedPseudograph<>(Edge.class);
    }
    
    @PostConstruct
    public void initialize() {
        // Load graph from persistence on startup
        loadGraphFromPersistence();
    }
    
    public void fullIndex(DataSource source) {
        // 1. Parse source and build JGraphT graph
        inMemoryGraph.removeAllVertices(new HashSet<>(inMemoryGraph.vertexSet()));
        
        // 2. Index into persistence (PostgreSQL/DuckDB)
        List<Node> nodes = extractNodesFromSource(source);
        List<Edge> edges = extractEdgesFromSource(source);
        
        // 3. Batch persist
        nodeRepository.saveAll(nodes);
        edgeRepository.saveAll(edges);
        
        // 4. Update in-memory graph
        nodes.forEach(inMemoryGraph::addVertex);
        edges.forEach(edge -> inMemoryGraph.addEdge(
            findNode(edge.getSourceNodeId()),
            findNode(edge.getTargetNodeId()),
            edge
        ));
    }
    
    public void incrementalIndex(NodeInput nodeInput) {
        // 1. Create Node entity
        Node node = nodeInput.toNode();
        
        // 2. Persist to database
        nodeRepository.save(node);
        
        // 3. Update in-memory JGraphT
        inMemoryGraph.addVertex(node);
    }
    
    public void incrementalIndex(EdgeInput edgeInput) {
        // 1. Create Edge entity
        Edge edge = edgeInput.toEdge();
        
        // 2. Persist to database
        edgeRepository.save(edge);
        
        // 3. Update in-memory JGraphT
        Node source = findNode(edge.getSourceNodeId());
        Node target = findNode(edge.getTargetNodeId());
        inMemoryGraph.addEdge(source, target, edge);
    }
    
    public List<Node> getNeighbors(UUID nodeId, int depth) {
        Node startNode = findNode(nodeId);
        
        // Use JGraphT BFS iterator
        BreadthFirstIterator<Node, Edge> bfsIterator = 
            new BreadthFirstIterator<>(inMemoryGraph, startNode, depth);
        
        List<Node> neighbors = new ArrayList<>();
        bfsIterator.forEachRemaining(neighbors::add);
        
        return neighbors;
    }
    
    public List<List<Node>> findPaths(UUID sourceId, UUID targetId) {
        Node source = findNode(sourceId);
        Node target = findNode(targetId);
        
        // Use JGraphT path finding
        AllDirectedPaths<Node, Edge> pathFinder = 
            new AllDirectedPaths<>(inMemoryGraph);
        
        List<GraphPath<Node, Edge>> graphPaths = 
            pathFinder.getAllPaths(source, target, true, 5);
        
        return graphPaths.stream()
            .map(GraphPath::getVertexList)
            .toList();
    }
    
    private void loadGraphFromPersistence() {
        List<Node> nodes = nodeRepository.findAll();
        List<Edge> edges = edgeRepository.findAll();
        
        nodes.forEach(inMemoryGraph::addVertex);
        edges.forEach(edge -> inMemoryGraph.addEdge(
            findNode(edge.getSourceNodeId()),
            findNode(edge.getTargetNodeId()),
            edge
        ));
        
        logger.info("Loaded {} nodes and {} edges into in-memory graph",
            nodes.size(), edges.size());
    }
    
    private Node findNode(UUID id) {
        return inMemoryGraph.vertexSet().stream()
            .filter(n -> n.getId().equals(id))
            .findFirst()
            .orElseThrow(() -> new NodeNotFoundException(id));
    }
}
```

---

## Entity Lifecycle Hooks

### Audit Trail and Validation

```java
@Component
@EntityListener
public class MedicalEntityListener {
    
    private final AuditService auditService;
    private final NotificationService notificationService;
    private final CacheManager cacheManager;
    
    @PrePersist
    public void beforeCreate(Node node) {
        // Set audit fields
        String currentUser = SecurityContextHolder.getContext()
            .getAuthentication().getName();
        node.getProperties().put("createdBy", currentUser);
        node.getProperties().put("createdAt", Instant.now());
        
        // Domain-specific validation
        if ("Patient".equals(node.getLabel())) {
            validatePatient(node);
        }
        
        logger.info("Creating {} node: {}", node.getLabel(), node.getId());
    }
    
    @PostPersist
    public void afterCreate(Node node) {
        // Send notifications
        if ("Patient".equals(node.getLabel())) {
            notificationService.sendPatientCreatedEvent(node);
        }
        
        // Update search index
        searchIndexService.indexNode(node);
        
        // Audit log
        auditService.log(AuditAction.CREATE, node);
    }
    
    @PreUpdate
    public void beforeUpdate(Node node, Map<String, Object> changes) {
        // Audit trail
        String currentUser = SecurityContextHolder.getContext()
            .getAuthentication().getName();
        node.getProperties().put("updatedBy", currentUser);
        node.getProperties().put("updatedAt", Instant.now());
        
        // Log changes
        auditService.logChanges(node.getId(), changes);
        
        logger.info("Updating {} node: {}", node.getLabel(), node.getId());
    }
    
    @PostUpdate
    public void afterUpdate(Node node) {
        // Invalidate caches
        cacheManager.evict("patients", node.getId());
        cacheManager.evict("node-by-label", node.getLabel());
        
        // Update search index
        searchIndexService.updateNode(node);
    }
    
    @PreRemove
    public void beforeDelete(Node node) {
        // Business rule: Cannot delete patient with active appointments
        if ("Patient".equals(node.getLabel())) {
            List<Edge> appointments = edgeRepository.findActiveAppointments(node.getId());
            if (!appointments.isEmpty()) {
                throw new ConstraintViolationException(
                    "Cannot delete patient with active appointments");
            }
        }
        
        // Backup data before deletion
        backupService.backup(node);
        
        logger.warn("Deleting {} node: {}", node.getLabel(), node.getId());
    }
    
    @PostRemove
    public void afterDelete(Node node) {
        // Cleanup orphaned data
        cleanupService.removeOrphanedChunks(node.getId());
        
        // Remove from search index
        searchIndexService.removeNode(node.getId());
        
        // Audit
        auditService.log(AuditAction.DELETE, node);
    }
    
    private void validatePatient(Node node) {
        Map<String, Object> props = node.getProperties();
        
        if (!props.containsKey("mrn") || 
            ((String) props.get("mrn")).length() < 5) {
            throw new ValidationException("Medical Record Number must be at least 5 characters");
        }
        
        if (!props.containsKey("age") || 
            (int) props.get("age") < 0 || (int) props.get("age") > 150) {
            throw new ValidationException("Age must be between 0 and 150");
        }
    }
}
```

---

## Data Seeding with PDF Prescriptions

### Sample PDF Prescription Documents

The example includes real-world PDF prescription formats in `data/seed/prescriptions/`:

**File: `data/seed/prescriptions/prescription_001.pdf`**

```
╔══════════════════════════════════════════════════════════════╗
║            City General Hospital                              ║
║            123 Medical Plaza, NY 10001                        ║
║            Phone: (555) 123-4567                              ║
╚══════════════════════════════════════════════════════════════╝

PRESCRIPTION

Date: March 15, 2024

PATIENT INFORMATION:
Name: John Doe
DOB: 05/12/1978 (Age: 45)
Gender: Male
Medical Record #: MRN-12345
Allergies: Penicillin, Latex

PRESCRIBING PHYSICIAN:
Dr. Sarah Johnson, MD
Specialization: Cardiology
License: MD-54321

DIAGNOSIS:
Primary: Hypertension (ICD-10: I10)
Secondary: Hyperlipidemia (ICD-10: E78.5)

MEDICATIONS PRESCRIBED:

1. Lisinopril 10mg Tablet
   Sig: Take 1 tablet by mouth once daily
   Quantity: 30 tablets
   Refills: 3
   Duration: 3 months
   
2. Atorvastatin 20mg Tablet
   Sig: Take 1 tablet by mouth once daily at bedtime
   Quantity: 30 tablets
   Refills: 3
   Duration: 3 months

INSTRUCTIONS:
- Monitor blood pressure daily
- Follow low-sodium diet
- Follow up in 30 days

Physician Signature: [Signed]
Date: 03/15/2024
```

**File: `data/seed/prescriptions/prescription_002.pdf`**

```
╔══════════════════════════════════════════════════════════════╗
║         Metro Diabetes & Endocrine Center                     ║
║         456 Health Ave, NY 10002                              ║
║         Phone: (555) 987-6543                                 ║
╚══════════════════════════════════════════════════════════════╝

PRESCRIPTION

Date: January 10, 2024

PATIENT INFORMATION:
Name: Jane Smith
DOB: 08/22/1985 (Age: 38)
Gender: Female
Medical Record #: MRN-12346
Allergies: None Known

PRESCRIBING PHYSICIAN:
Dr. Michael Chen, MD
Specialization: Endocrinology
License: MD-54322

DIAGNOSIS:
Primary: Type 2 Diabetes Mellitus (ICD-10: E11.9)

MEDICATIONS PRESCRIBED:

1. Metformin 500mg Tablet
   Sig: Take 1 tablet by mouth twice daily with meals
   Quantity: 60 tablets
   Refills: 5
   Duration: 1 month
   
2. Glipizide 5mg Tablet
   Sig: Take 1 tablet by mouth once daily before breakfast
   Quantity: 30 tablets
   Refills: 5
   Duration: 1 month

INSTRUCTIONS:
- Check blood glucose before meals and at bedtime
- Follow diabetic diet plan
- Exercise 30 minutes daily
- Follow up in 2 weeks with lab results

Lab Orders:
- HbA1c
- Fasting Blood Glucose
- Lipid Panel

Physician Signature: [Signed]
Date: 01/10/2024
```

**File: `data/seed/prescriptions/prescription_003.pdf`**

```
╔══════════════════════════════════════════════════════════════╗
║         Central Medical Clinic                                ║
║         789 Care Street, NY 10003                             ║
╚══════════════════════════════════════════════════════════════╝

PRESCRIPTION

Date: February 20, 2024

PATIENT: Emily Rodriguez
Age: 62 | Gender: F | MRN: MRN-12347
Allergies: Sulfa drugs

PHYSICIAN: Dr. Robert Williams, MD - Internal Medicine
License: MD-54323

DIAGNOSIS: Chronic Kidney Disease Stage 3 (ICD-10: N18.3)

Rx:
1. Losartan 50mg - 1 tab PO daily
   #30, Refills: 6
   
2. Sodium Bicarbonate 650mg - 1 tab PO TID
   #90, Refills: 3
   
3. Vitamin D3 2000 IU - 1 tab PO daily
   #30, Refills: 6

Notes:
- Restrict protein intake to 0.8g/kg/day
- Monitor serum creatinine monthly
- Next appointment: 3 months

Dr. Williams
02/20/2024
```

### ANTLR Grammar for Prescription Parsing

```antlr
// Prescription.g4
grammar Prescription;

document
    : header patient physician diagnosis medications instructions signature
    ;

header
    : HOSPITAL_NAME address phone
    ;

patient
    : 'PATIENT' ('INFORMATION')? ':'
      'Name:' NAME
      ('DOB:' DATE)? ('Age:' AGE)?
      'Gender:' GENDER
      ('Medical Record' ('#' | 'Number' | '#:'))? MRN
      'Allergies:' allergies
    ;

physician
    : 'PRESCRIBING PHYSICIAN' | 'PHYSICIAN' ':'
      NAME ',' ('MD' | 'DO')
      ('Specialization' | 'Specialty')? ':' SPECIALTY
      'License:' LICENSE
    ;

diagnosis
    : 'DIAGNOSIS' ':'
      ('Primary:' condition)+
      ('Secondary:' condition)*
    ;

medications
    : 'MEDICATIONS PRESCRIBED' ':'
      medication+
    ;

medication
    : NUMBER '.' drugName dosage
      'Sig:' instructions
      'Quantity:' quantity
      'Refills:' refills
      ('Duration:' duration)?
    ;

// ... lexer rules
```

---

## Application Initialization

### MedicalKnowledgeApplication

```java
@SpringBootApplication
@EnableCaching
public class MedicalKnowledgeApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(MedicalKnowledgeApplication.class, args);
    }
}

@Component
public class MedicalDataInitializer implements ApplicationRunner {
    
    private final KnowledgeIndexer indexer;
    private final DataSourceFactory dataSourceFactory;
    private final MedicalGraphManager graphManager;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        logger.info("Initializing medical knowledge graph...");
        
        // 1. Initialize framework with root nodes and relation types
        List<NodeInput> rootNodes = List.of(
            new NodeInput(
                UUID.randomUUID(),
                "MedicalEntity",
                Map.of("description", "Root of medical ontology"),
                null
            ),
            new NodeInput(
                UUID.randomUUID(),
                "ClinicalProcess",
                Map.of("description", "Root of clinical processes"),
                null
            )
        );
        
        List<RelationType> relationTypes = createMedicalRelationTypes();
        
        indexer.initialize(rootNodes, relationTypes);
        
        // 2. Full index from FileSystem DataSource
        DataSource fileSystem = dataSourceFactory.create(
            DataSourceType.FILESYSTEM,
            Map.of("path", "data/seed")
        );
        
        IndexResult fsResult = indexer.fullIndex(fileSystem);
        
        logger.info("Indexed from filesystem: {} nodes, {} edges, {} chunks in {}ms",
            fsResult.getNodesIndexed(),
            fsResult.getEdgesIndexed(),
            fsResult.getChunksIndexed(),
            fsResult.getDurationMs());
        
        // 3. Optional: Index from S3/MinIO BlobStorage (for testing)
        if (shouldIndexFromBlobStorage()) {
            DataSource blobStorage = dataSourceFactory.create(
                DataSourceType.BLOB_STORAGE,
                Map.of(
                    "endpoint", "http://localhost:9000",
                    "bucket", "medical-documents",
                    "accessKey", "minioadmin",
                    "secretKey", "minioadmin"
                )
            );
            
            IndexResult blobResult = indexer.fullIndex(blobStorage);
            
            logger.info("Indexed from blob storage: {} nodes, {} edges, {} chunks",
                blobResult.getNodesIndexed(),
                blobResult.getEdgesIndexed(),
                blobResult.getChunksIndexed());
        }
    }
    
    private boolean shouldIndexFromBlobStorage() {
        return environment.getProperty("cef.datasources.blob-storage.enabled", 
            Boolean.class, false);
    }
}
```

---

## REST API Controllers

### ChatController

```java
@RestController
@RequestMapping("/api/chat")
public class ChatController {
    
    private final KnowledgeRetriever retriever;
    private final DefaultContextProviderTool contextProvider;
    private final LLMClientFactory llmFactory;
    
    @PostMapping
    public ResponseEntity<ChatResponse> chat(@RequestBody @Valid ChatRequest request) {
        // 1. Use context provider to assemble context
        ContextResponse context = contextProvider.provideContext(
            ContextRequest.builder()
                .addQuery(request.getMessage())
                .tokenBudget(request.getTokenBudget())
                .build()
        );
        
        // 2. Build prompt with context
        String prompt = buildPrompt(request.getMessage(), context);
        
        // 3. Get LLM response
        LLMClient llm = llmFactory.getClient(
            request.getProvider(),
            request.getLlmConfig()
        );
        
        String response = llm.generate(prompt, request.getLlmConfig());
        
        // 4. Return with context metadata
        return ResponseEntity.ok(new ChatResponse(
            response,
            context,
            request.getConversationId()
        ));
    }
    
    @PostMapping("/stream")
    public Flux<ServerSentEvent<String>> chatStream(@RequestBody @Valid ChatRequest request) {
        // Streaming implementation
        return Flux.create(sink -> {
            // ... streaming logic
        });
    }
    
    private String buildPrompt(String userMessage, ContextResponse context) {
        return String.format("""
            You are a medical AI assistant. Answer based on the provided context.
            
            %s
            
            User Question: %s
            
            Answer:
            """,
            context.toPromptContext(),
            userMessage
        );
    }
}
```

### GraphController

```java
@RestController
@RequestMapping("/api/graph")
public class GraphController {
    
    private final KnowledgeRetriever retriever;
    
    @GetMapping("/entity/{id}")
    public ResponseEntity<GraphEntityResponse> getEntity(@PathVariable UUID id) {
        Optional<Node> node = retriever.findNode(id);
        
        if (node.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        
        // Get relationships
        List<Edge> edges = retriever.getNeighbors(id)
            .stream()
            .map(n -> /* get edge */)
            .toList();
        
        // Extract subgraph
        ReasoningContext context = retriever.extractContext(id, 2, null);
        
        return ResponseEntity.ok(new GraphEntityResponse(
            node.get(),
            edges,
            context
        ));
    }
    
    @GetMapping("/context/{conversationId}")
    public ResponseEntity<GraphContextResponse> getConversationContext(
        @PathVariable String conversationId
    ) {
        // Retrieve context used in conversation
        // ... implementation
    }
    
    @PostMapping("/query")
    public ResponseEntity<GraphQueryResponse> query(@RequestBody @Valid GraphQuery query) {
        // Execute graph query
        SearchResult result = retriever.retrieve(
            RetrievalRequest.builder()
                .startNodeId(query.getStartNodeId())
                .query(query.getQuery())
                .depth(query.getDepth())
                .build()
        );
        
        return ResponseEntity.ok(new GraphQueryResponse(result));
    }
}
```

---

## React Frontend

### Chat Component

```typescript
// frontend/src/components/Chat/ChatWindow.tsx
import { useState } from 'react';
import { useMutation } from '@tanstack/react-query';
import { chatApi } from '@/services/api';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  context?: ContextResponse;
}

export function ChatWindow() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  
  const chatMutation = useMutation({
    mutationFn: chatApi.sendMessage,
    onSuccess: (data) => {
      setMessages(prev => [
        ...prev,
        { role: 'assistant', content: data.response, context: data.context }
      ]);
    }
  });
  
  const handleSend = () => {
    const userMessage = { role: 'user' as const, content: input };
    setMessages(prev => [...prev, userMessage]);
    
    chatMutation.mutate({
      message: input,
      conversationId: 'uuid',
      provider: 'ollama',
      tokenBudget: 4000
    });
    
    setInput('');
  };
  
  return (
    <div className="flex h-screen">
      {/* Chat messages */}
      <div className="flex-1 flex flex-col">
        <MessageList messages={messages} />
        <InputBox 
          value={input}
          onChange={setInput}
          onSend={handleSend}
          loading={chatMutation.isPending}
        />
      </div>
      
      {/* Context graph */}
      <div className="w-1/2 border-l">
        {messages[messages.length - 1]?.context && (
          <ContextGraph context={messages[messages.length - 1].context} />
        )}
      </div>
    </div>
  );
}
```

### Graph Visualization

```typescript
// frontend/src/components/Graph/KnowledgeGraph.tsx
import ForceGraph2D from 'react-force-graph-2d';
import { useQuery } from '@tanstack/react-query';
import { graphApi } from '@/services/api';

export function KnowledgeGraph({ contextData }: { contextData?: ReasoningContext }) {
  const { data: graphData } = useQuery({
    queryKey: ['graph'],
    queryFn: graphApi.getFullGraph
  });
  
  // Convert to force-graph format
  const formatData = () => {
    return {
      nodes: graphData?.nodes.map(n => ({
        id: n.id,
        label: n.label,
        val: 10,
        color: getNodeColor(n.label)
      })),
      links: graphData?.edges.map(e => ({
        source: e.sourceNodeId,
        target: e.targetNodeId,
        label: e.relationType
      }))
    };
  };
  
  return (
    <ForceGraph2D
      graphData={formatData()}
      nodeLabel="label"
      nodeColor="color"
      linkDirectionalArrowLength={6}
      linkDirectionalArrowRelPos={1}
      onNodeClick={handleNodeClick}
      nodeCanvasObject={(node, ctx, globalScale) => {
        // Custom rendering with highlighting for context nodes
        const isHighlighted = contextData?.relatedNodes.some(
          n => n.id === node.id
        );
        
        ctx.fillStyle = isHighlighted ? '#ff6b6b' : node.color;
        ctx.beginPath();
        ctx.arc(node.x, node.y, 5, 0, 2 * Math.PI);
        ctx.fill();
      }}
    />
  );
}
```

---

## Configuration

### application.yml

```yaml
spring:
  application:
    name: medical-knowledge-assistant
  
  datasource:
    url: jdbc:postgresql://localhost:5432/medical_cef
    username: cef_user
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
  
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=10000,expireAfterWrite=1h

cef:
  storage:
    type: postgresql
    schemas:
      graph: medical_graph
      vector: medical_vector
  
  embedding:
    provider: ollama
    model: nomic-embed-text
    dimension: 768
    base-url: http://localhost:11434
  
  llm:
    provider: ollama
    model: llama3
    base-url: http://localhost:11434
    temperature: 0.7
    max-tokens: 1000
  
  search:
    default-depth: 2
    default-top-k: 10
    min-results-threshold: 3
  
  context:
    default-token-budget: 4000
  
  datasources:
    filesystem:
      enabled: true
      root-path: data/seed

management:
  endpoints:
    web:
      exposure:
        include: health,metrics,info
  metrics:
    export:
      prometheus:
        enabled: true
```

---

## Docker Compose

```yaml
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg15
    environment:
      POSTGRES_DB: medical_cef
      POSTGRES_USER: cef_user
      POSTGRES_PASSWORD: cef_password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  ollama:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    command: >
      sh -c "ollama serve & 
             sleep 5 && 
             ollama pull llama3 && 
             ollama pull nomic-embed-text &&
             wait"
  
  backend:
    build: ./backend
    depends_on:
      - postgres
      - ollama
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/medical_cef
      SPRING_DATASOURCE_USERNAME: cef_user
      SPRING_DATASOURCE_PASSWORD: cef_password
      CEF_EMBEDDING_BASE_URL: http://ollama:11434
      CEF_LLM_BASE_URL: http://ollama:11434
    ports:
      - "8080:8080"
  
  frontend:
    build: ./frontend
    depends_on:
      - backend
    ports:
      - "3000:3000"
    environment:
      VITE_API_URL: http://localhost:8080

volumes:
  postgres_data:
  ollama_data:
```

---

## Summary

### What the Example Demonstrates

1. **ANTLR-Based Parser**: `MedicalYamlParser` uses ANTLR4 grammar for robust parsing with custom visitor pattern
2. **JGraphT In-Memory Graph**: Real-time graph traversal, path finding, BFS/DFS with persistence sync
3. **DataSource Adapters**: FileSystem and S3/MinIO blob storage indexing
4. **LLMClientFactory**: Multiple LLM providers (Ollama, vLLM) with DefaultContextProviderTool for multi-query context assembly
5. **Framework Relationships**: Uses mandatory IS_A, CONTAINS, CHILD_OF with domain extensions
6. **Lifecycle Hooks**: Audit trail, validation, notifications on entity create/update/delete
7. **Domain Mapping**: Medical entities → framework abstractions (Node, Edge, Chunk) - framework agnostic
8. **REST API**: Chat with context provider, graph query with reasoning paths
9. **React UI**: Chat with streaming, graph visualization with react-force-graph showing context reasoning
10. **Live Switching**: Change DB (PostgreSQL/DuckDB) and LLM provider without restart
11. **Production Ready**: Caching, validation, observability, Docker deployment

### User Journey

1. User starts app: `docker-compose up`
2. Framework indexes PDF prescriptions from `data/seed/prescriptions/*.pdf`
   - Extracts 50+ patients, 15 doctors, 30 conditions, 100+ medications
   - Builds knowledge graph with relationships
3. User asks natural language query: **"Show me all patients with diabetes and their medications"**
4. System:
   - Retrieves context via hybrid search (graph + VSS + BM25)
   - Finds relevant nodes: Jane Smith (Patient) → Type 2 Diabetes → Metformin, Glipizide
   - Extracts reasoning path through graph
5. LLM generates answer using assembled context from prescription PDFs
6. UI displays:
   - **Answer**: "Jane Smith (Age 38, MRN-12346) has Type 2 Diabetes and is prescribed Metformin 500mg twice daily and Glipizide 5mg once daily"
   - **Graph visualization**: Shows reasoning path (Patient → Condition → Medications)
   - **Source**: Links to prescription_002.pdf
7. User asks follow-up: **"What are the side effects of Metformin?"**
8. System retrieves from knowledge base + external medical documents
9. User switches LLM provider (Ollama → OpenAI) without restart
10. Everything continues working seamlessly with PDF-extracted data

---

**Status:** Accepted  
**Date:** 2024-11-24  
**Next:** Implementation Phase 1 (Framework Core)

